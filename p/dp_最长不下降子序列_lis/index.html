<!DOCTYPE html>
<html lang="en-us">
    <head><meta charset='utf-8'>
<meta name='viewport' content='width=device-width, initial-scale=1'><meta name='description' content='序言 同类的问题还有*&amp;ldquo;最长上升子序列&amp;rdquo;, &amp;ldquo;最长下降子序列&amp;rdquo;, &amp;hellip;*
他们的不同就在于定义的core规则不同, 有的是&amp;gt;=, 有的是&amp;gt;, 有的是&amp;lt;
由此启发, 我们可以在解决其他的问题, 不一定是比较数的大小的问题里面抽象出这种模型.
下面介绍这种动态规划入门都会介绍的问题的思路.
首先我们从头开始分析这个问题.
一. 最容易想到的最暴力的方法 对这个序列中的每一个数的&amp;quot;有&amp;quot;和&amp;quot;无&amp;quot;分两种情况讨论. 代码实现上就是递归.
时间复杂度就是O(2^n)
代码实现上较为简单. 不展示
二. 第二种方法是O(n^2)的DP方法 动态规划的问题是无后效性的, 每个问题都可以分解为更小的子问题, 从而求解.
这道题也不例外.
这个序列的每一个数为止都有一个解, 作为子问题的解. 后面的问题的解就是从这些子问题的最优解继承过来的.
so, 给这个序列的解建立数组dp[n], 0 - n分别是截止到Ai的解.
 当下一个数要加入来的时候, 有两种情况
  前面的数都比当前数更大, 因此以这个数为止的最长不下降子序列的长度就是1. 遍历到第一个数的情况也包含在内.
  前面的数有不比当前数大的, 那么这个数的结果dp[i] = max(dp[i], dp[j] &#43; 1). 这个过程遍历前面所有数的dp[j]进行比较.
  最后的答案就是所有dp[i]里面的最大值.
 这种方法的时间复杂度是O(n^2), 可以看到相比于前面暴力递归的方法有了极大的进步.
代码通过样例, 但不一定能过题, 请谨慎使用.
#include &amp;lt;iostream&amp;gt; #include &amp;lt;vector&amp;gt; using namespace std; int main() { int n, x; vector&amp;lt;int&amp;gt; v; cin &amp;gt;&amp;gt; n; for (int i = 0; i &amp;lt; n; &#43;&#43;i) { cin &amp;gt;&amp;gt; x; v.'><title>DP_最长不下降子序列_LIS</title>

<link rel='canonical' href='https://example.com/p/dp_%E6%9C%80%E9%95%BF%E4%B8%8D%E4%B8%8B%E9%99%8D%E5%AD%90%E5%BA%8F%E5%88%97_lis/'>

<link rel="stylesheet" href="/scss/style.min.css"><meta property='og:title' content='DP_最长不下降子序列_LIS'>
<meta property='og:description' content='序言 同类的问题还有*&amp;ldquo;最长上升子序列&amp;rdquo;, &amp;ldquo;最长下降子序列&amp;rdquo;, &amp;hellip;*
他们的不同就在于定义的core规则不同, 有的是&amp;gt;=, 有的是&amp;gt;, 有的是&amp;lt;
由此启发, 我们可以在解决其他的问题, 不一定是比较数的大小的问题里面抽象出这种模型.
下面介绍这种动态规划入门都会介绍的问题的思路.
首先我们从头开始分析这个问题.
一. 最容易想到的最暴力的方法 对这个序列中的每一个数的&amp;quot;有&amp;quot;和&amp;quot;无&amp;quot;分两种情况讨论. 代码实现上就是递归.
时间复杂度就是O(2^n)
代码实现上较为简单. 不展示
二. 第二种方法是O(n^2)的DP方法 动态规划的问题是无后效性的, 每个问题都可以分解为更小的子问题, 从而求解.
这道题也不例外.
这个序列的每一个数为止都有一个解, 作为子问题的解. 后面的问题的解就是从这些子问题的最优解继承过来的.
so, 给这个序列的解建立数组dp[n], 0 - n分别是截止到Ai的解.
 当下一个数要加入来的时候, 有两种情况
  前面的数都比当前数更大, 因此以这个数为止的最长不下降子序列的长度就是1. 遍历到第一个数的情况也包含在内.
  前面的数有不比当前数大的, 那么这个数的结果dp[i] = max(dp[i], dp[j] &#43; 1). 这个过程遍历前面所有数的dp[j]进行比较.
  最后的答案就是所有dp[i]里面的最大值.
 这种方法的时间复杂度是O(n^2), 可以看到相比于前面暴力递归的方法有了极大的进步.
代码通过样例, 但不一定能过题, 请谨慎使用.
#include &amp;lt;iostream&amp;gt; #include &amp;lt;vector&amp;gt; using namespace std; int main() { int n, x; vector&amp;lt;int&amp;gt; v; cin &amp;gt;&amp;gt; n; for (int i = 0; i &amp;lt; n; &#43;&#43;i) { cin &amp;gt;&amp;gt; x; v.'>
<meta property='og:url' content='https://example.com/p/dp_%E6%9C%80%E9%95%BF%E4%B8%8D%E4%B8%8B%E9%99%8D%E5%AD%90%E5%BA%8F%E5%88%97_lis/'>
<meta property='og:site_name' content='Example Site'>
<meta property='og:type' content='article'><meta property='article:section' content='Post' /><meta property='article:published_time' content='2018-07-11T00:00:00&#43;00:00'/><meta property='article:modified_time' content='2018-07-11T00:00:00&#43;00:00'/>
<meta name="twitter:title" content="DP_最长不下降子序列_LIS">
<meta name="twitter:description" content="序言 同类的问题还有*&amp;ldquo;最长上升子序列&amp;rdquo;, &amp;ldquo;最长下降子序列&amp;rdquo;, &amp;hellip;*
他们的不同就在于定义的core规则不同, 有的是&amp;gt;=, 有的是&amp;gt;, 有的是&amp;lt;
由此启发, 我们可以在解决其他的问题, 不一定是比较数的大小的问题里面抽象出这种模型.
下面介绍这种动态规划入门都会介绍的问题的思路.
首先我们从头开始分析这个问题.
一. 最容易想到的最暴力的方法 对这个序列中的每一个数的&amp;quot;有&amp;quot;和&amp;quot;无&amp;quot;分两种情况讨论. 代码实现上就是递归.
时间复杂度就是O(2^n)
代码实现上较为简单. 不展示
二. 第二种方法是O(n^2)的DP方法 动态规划的问题是无后效性的, 每个问题都可以分解为更小的子问题, 从而求解.
这道题也不例外.
这个序列的每一个数为止都有一个解, 作为子问题的解. 后面的问题的解就是从这些子问题的最优解继承过来的.
so, 给这个序列的解建立数组dp[n], 0 - n分别是截止到Ai的解.
 当下一个数要加入来的时候, 有两种情况
  前面的数都比当前数更大, 因此以这个数为止的最长不下降子序列的长度就是1. 遍历到第一个数的情况也包含在内.
  前面的数有不比当前数大的, 那么这个数的结果dp[i] = max(dp[i], dp[j] &#43; 1). 这个过程遍历前面所有数的dp[j]进行比较.
  最后的答案就是所有dp[i]里面的最大值.
 这种方法的时间复杂度是O(n^2), 可以看到相比于前面暴力递归的方法有了极大的进步.
代码通过样例, 但不一定能过题, 请谨慎使用.
#include &amp;lt;iostream&amp;gt; #include &amp;lt;vector&amp;gt; using namespace std; int main() { int n, x; vector&amp;lt;int&amp;gt; v; cin &amp;gt;&amp;gt; n; for (int i = 0; i &amp;lt; n; &#43;&#43;i) { cin &amp;gt;&amp;gt; x; v.">
    </head>
    <body class="
    article-page has-toc
">
    <script>
        (function() {
            const colorSchemeKey = 'StackColorScheme';
            if(!localStorage.getItem(colorSchemeKey)){
                localStorage.setItem(colorSchemeKey, "auto");
            }
        })();
    </script><script>
    (function() {
        const colorSchemeKey = 'StackColorScheme';
        const colorSchemeItem = localStorage.getItem(colorSchemeKey);
        const supportDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches === true;

        if (colorSchemeItem == 'dark' || colorSchemeItem === 'auto' && supportDarkMode) {
            

            document.documentElement.dataset.scheme = 'dark';
        } else {
            document.documentElement.dataset.scheme = 'light';
        }
    })();
</script>
<div class="container main-container flex 
    
        extended
    
">
    
        <div id="article-toolbar">
            <a href="https://example.com" class="back-home">
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-chevron-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <polyline points="15 6 9 12 15 18" />
</svg>



                <span>Back</span>
            </a>
        </div>
    
<main class="main full-width">
    <article class="main-article">
    <header class="article-header">

    <div class="article-details">
    
    <header class="article-category">
        
            <a href="/categories/%E7%AE%97%E6%B3%95/" >
                算法
            </a>
        
    </header>
    

    <h2 class="article-title">
        <a href="/p/dp_%E6%9C%80%E9%95%BF%E4%B8%8D%E4%B8%8B%E9%99%8D%E5%AD%90%E5%BA%8F%E5%88%97_lis/">DP_最长不下降子序列_LIS</a>
    </h2>

    

    
    <footer class="article-time">
        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <path d="M11.795 21h-6.795a2 2 0 0 1 -2 -2v-12a2 2 0 0 1 2 -2h12a2 2 0 0 1 2 2v4" />
  <circle cx="18" cy="18" r="4" />
  <path d="M15 3v4" />
  <path d="M7 3v4" />
  <path d="M3 11h16" />
  <path d="M18 16.496v1.504l1 1" />
</svg>
                <time class="article-time--published">Jul 11, 2018</time>
            </div>
        

        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <polyline points="12 7 12 12 15 15" />
</svg>



                <time class="article-time--reading">
                    2 minute read
                </time>
            </div>
        
    </footer>
    
</div>
</header>

    <section class="article-content">
    <h3 id="序言">序言</h3>
<p>同类的问题还有*&ldquo;最长上升子序列&rdquo;, &ldquo;最长下降子序列&rdquo;, &hellip;*</p>
<p>他们的不同就在于<strong>定义的core规则不同</strong>, 有的是&gt;=, 有的是&gt;, 有的是&lt;</p>
<p>由此启发, 我们可以在解决其他的问题, <strong>不一定是比较数的大小的问题里面抽象出这种模型.</strong></p>
<p>下面介绍这种动态规划入门都会介绍的问题的思路.</p>
<p>首先我们从头开始分析这个问题.</p>
<h3 id="一-最容易想到的最暴力的方法">一. 最容易想到的最暴力的方法</h3>
<p>对这个序列中的每一个数的&quot;有&quot;和&quot;无&quot;分两种情况讨论. 代码实现上就是递归.</p>
<p><strong>时间复杂度就是O(2^n)</strong></p>
<p>代码实现上较为简单. 不展示</p>
<h3 id="二-第二种方法是on2的dp方法">二. 第二种方法是O(n^2)的DP方法</h3>
<p><strong>动态规划的问题是无后效性的, 每个问题都可以分解为更小的子问题, 从而求解.</strong></p>
<p>这道题也不例外.</p>
<p>这个序列的每一个数为止都有一个解, 作为子问题的解. 后面的问题的解就是从这些子问题的最优解继承过来的.</p>
<p>so, 给这个序列的解建立数组dp[n], 0 - n分别是截止到Ai的解.</p>
<blockquote>
<p>当下一个数要加入来的时候, 有两种情况</p>
<ol>
<li>
<p>前面的数都比当前数更大, 因此以这个数为止的最长不下降子序列的长度就是1. 遍历到第一个数的情况也包含在内.</p>
</li>
<li>
<p>前面的数有不比当前数大的, 那么这个数的结果dp[i] = max(dp[i], dp[j] + 1). 这个过程遍历前面所有数的dp[j]进行比较.</p>
</li>
</ol>
<p><strong>最后的答案就是所有dp[i]里面的最大值.</strong></p>
</blockquote>
<p>这种方法的<strong>时间复杂度是O(n^2)</strong>, 可以看到相比于前面暴力递归的方法有了极大的进步.</p>
<p>代码通过样例, 但不一定能过题, 请谨慎使用.</p>
<pre tabindex="0"><code>#include &lt;iostream&gt;
#include &lt;vector&gt;
using namespace std;

int main()
{
	int n, x;
	vector&lt;int&gt; v;
	cin &gt;&gt; n;
	for (int i = 0; i &lt; n; ++i) {
		cin &gt;&gt; x;
		v.push_back(x);
	}
	int dp[(int)v.size()] = {1}, ans = 1;
	for (int i = 1; i &lt; (int)v.size(); ++i) {
		for (int j = 0; j &lt; i; ++j) {
			if (v[i] &gt;= v[j]) dp[i] = max(dp[i], dp[j] + 1); // 状态转移方程
		}
		ans = max(ans, dp[i]);
	}
	cout &lt;&lt; ans;
}
/*
8
1 2 3 -9 3 9 0 11
*/
</code></pre><h3 id="三-onlogn方法-维护单调数组">三. O(nlogn)方法, 维护单调数组</h3>
<p>这个方法也是DP方法</p>
<p>时间复杂度可以从O(n^2)降到O(n log n).</p>
<p><strong>我们从最长上升子序列的角度来探讨</strong></p>
<p>假设对一个序列n[1&hellip;9] = {2 1 5 3 6 4 8 9 7}, 维护一个单调数组, 使得这个数组为最长上升子序列. 设这个数组为d[ ].</p>
<p>对n[1] = 2, 使得d[1] = 2;</p>
<p>对n[2] = 1, 因为1比2小, 所以修改d[1]的值, 使其为1</p>
<p>对n[3] = 5, 5比1大, 所以len++, d[2] = 5</p>
<p>对n[4] = 3, 3比1大比5小, 所以替换掉5, 使d[2] = 3</p>
<p>对n[5] = 6, 6比d[2]大, 所以len++, d[3] = 6</p>
<p>对n[6] = 4, 4比3大比6小, 所以替换掉6, 使d[3] = 4</p>
<p>对n[7] = 8, 8比4大, 所以len++, 使d[4] = 8</p>
<p>对n[8] = 9, 9比8大, 所以len++, 使d[5] = 9</p>
<p>对n[9] = 7, 7比4大比8小, 所以替换掉8, 使d[4] = 7.</p>
<p>至此这个序列遍历完了, 最小的长度也出来了. 最后的序列是1 3 4 7 9, len = 5</p>
<p>仔细琢磨会觉得, <strong>如最后一步操作, 为什么后面的7反而到他前面的8, 9的前面去了.</strong> 其实仔细一想并无问题, 因为即使7出现在前面, 它并不影响最终结果, <strong>因为我们已经得出最后结果就是len</strong>, 而以7为结尾的最长序列在该题中是len - 1, 如果后面还有序列, <strong>那么这里把7替换掉8会使得当前状态更优, 因为这样的修改是不会改变当前结果的, 但是确实后续最优状态的基础. 而这道题的动态规划思想就是这样, 不断地获取最优状态.</strong></p>
<p>经过前面的分析我们也许会发现, 这个DP的过程无法存储中间结果, 也就是说<strong>我们只能知道最长的子序列是多长, 而无法得到是哪个序列.</strong> 可谓是有利有弊.</p>
<p>利用我们维护的数组的单调性, 我们可以用二分法查找这个比当前数更大数的位置, 从而方便的实现替换.</p>
<p>所以时间复杂度为O(n log n).</p>
<pre tabindex="0"><code>#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
using namespace std;

int main()
{
	int n, x;
	vector&lt;int&gt; v, vec;
	cin &gt;&gt; n;
	for (int i = 0; i &lt; n; ++i) {
		cin &gt;&gt; x;
		v.push_back(x);
	}
	for (int i = 0; i &lt; (int)v.size(); ++i) {
		if (i == 0) vec.push_back(v[0]);
		else {
			if (v[i] &gt;= vec[vec.size() - 1]) vec.push_back(v[i]);
			else *upper_bound(vec.begin(), vec.end(), v[i]) = v[i];
		}
	}
	for (int i = 0; i &lt; (int)vec.size(); ++i) {
		cout &lt;&lt; vec[i] &lt;&lt; ' ';
	}
	cout &lt;&lt; endl;
	cout &lt;&lt; &quot;len == &quot; &lt;&lt; vec.size() &lt;&lt; endl;
}

/*
9
2 1 5 3 6 4 8 9 7
*/
</code></pre>
</section>


    <footer class="article-footer">
    

    
    <section class="article-copyright">
        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <path d="M14.5 9a3.5 4 0 1 0 0 6" />
</svg>



        <span>Licensed under CC BY-NC-SA 4.0</span>
    </section>
    </footer>


    
</article>

    <aside class="related-contents--wrapper">
    
    
        <h2 class="section-title">Related contents</h2>
        <div class="related-contents">
            <div class="flex article-list--tile">
                
                    
<article class="">
    <a href="/p/leetcode%E9%93%BE%E8%A1%A8%E4%B8%93%E9%A2%98/">
        
        

        <div class="article-details">
            <h2 class="article-title">Leetcode链表专题</h2>
        </div>
    </a>
</article>
                
                    
<article class="">
    <a href="/p/%E9%9A%8F%E6%9C%BA%E6%A0%91%E7%94%9F%E6%88%90%E7%AE%97%E6%B3%95-%E5%B0%B1%E6%98%AF%E6%A0%91/">
        
        

        <div class="article-details">
            <h2 class="article-title">随机树生成算法 就是树! </h2>
        </div>
    </a>
</article>
                
                    
<article class="">
    <a href="/p/ida-star%E7%AE%97%E6%B3%95%E8%A7%A3%E5%8D%81%E5%85%AD%E5%AE%AB%E6%A0%BC%E6%8B%BC%E5%9B%BE%E9%97%AE%E9%A2%98/">
        
        

        <div class="article-details">
            <h2 class="article-title">IDA Star算法解十六宫格拼图问题</h2>
        </div>
    </a>
</article>
                
                    
<article class="">
    <a href="/p/%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97/">
        
        

        <div class="article-details">
            <h2 class="article-title">数组中出现次数超过一半的数字</h2>
        </div>
    </a>
</article>
                
                    
<article class="">
    <a href="/p/tarjan%E7%AE%97%E6%B3%95%E7%BC%A9%E7%82%B9-dag%E6%9C%80%E9%95%BF%E8%B7%AF-dp/">
        
        

        <div class="article-details">
            <h2 class="article-title">Tarjan算法缩点&#43;DAG最长路 DP</h2>
        </div>
    </a>
</article>
                
            </div>
        </div>
    
</aside>

     
    
        
    <div class="disqus-container">
    <div id="disqus_thread"></div>
<script type="application/javascript">
    var disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "hugo-theme-stack" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</div>

<style>
    .disqus-container {
        background-color: var(--card-background);
        border-radius: var(--card-border-radius);
        box-shadow: var(--shadow-l1);
        padding: var(--card-padding);
    }
</style>

<script>
    window.addEventListener('onColorSchemeChange', (e) => {
        if (DISQUS) {
            DISQUS.reset({
                reload: true
            });
        }
    })
</script>

    

    <footer class="site-footer">
    <section class="copyright">
        &copy; 
        
            2020 - 
        
        2021 Example Site
    </section>
    
    <section class="powerby">
        Built with <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> <br />
        Theme <b><a href="https://github.com/CaiJimmy/hugo-theme-stack" target="_blank" rel="noopener" data-version="3.2.0">Stack</a></b> designed by <a href="https://jimmycai.com" target="_blank" rel="noopener">Jimmy</a>
    </section>
</footer>


    
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    
    <div class="pswp__bg"></div>

    
    <div class="pswp__scroll-wrap">

        
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                
                
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo="crossorigin="anonymous"
                defer="true"
                >
            </script><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU="crossorigin="anonymous"
                defer="true"
                >
            </script><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.css"integrity="sha256-c0uckgykQ9v5k&#43;IqViZOZKc47Jn7KQil4/MP3ySA3F8="crossorigin="anonymous"
            ><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.css"integrity="sha256-SBLU4vv6CA6lHsZ1XyTdhyjJxCjPif/TRkjnsyGAGnE="crossorigin="anonymous"
            >

            </main>
    
        <aside class="sidebar right-sidebar sticky">
            <section class="widget archives">
                <div class="widget-icon">
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <line x1="5" y1="9" x2="19" y2="9" />
  <line x1="5" y1="15" x2="19" y2="15" />
  <line x1="11" y1="4" x2="7" y2="20" />
  <line x1="17" y1="4" x2="13" y2="20" />
</svg>



                </div>
                <h2 class="widget-title section-title">Table of contents</h2>
                
                <div class="widget--toc">
                    <nav id="TableOfContents">
  <ol>
    <li>
      <ol>
        <li><a href="#序言">序言</a></li>
        <li><a href="#一-最容易想到的最暴力的方法">一. 最容易想到的最暴力的方法</a></li>
        <li><a href="#二-第二种方法是on2的dp方法">二. 第二种方法是O(n^2)的DP方法</a></li>
        <li><a href="#三-onlogn方法-维护单调数组">三. O(nlogn)方法, 维护单调数组</a></li>
      </ol>
    </li>
  </ol>
</nav>
                </div>
            </section>
        </aside>
    

        </div>
        <script 
                src="https://cdn.jsdelivr.net/npm/node-vibrant@3.1.5/dist/vibrant.min.js"integrity="sha256-5NovOZc4iwiAWTYIFiIM7DxKUXKWvpVEuMEPLzcm5/g="crossorigin="anonymous"
                defer="false"
                >
            </script><script type="text/javascript" src="/ts/main.js" defer></script>
<script>
    (function () {
        const customFont = document.createElement('link');
        customFont.href = "https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap";

        customFont.type = "text/css";
        customFont.rel = "stylesheet";

        document.head.appendChild(customFont);
    }());
</script>

    </body>
</html>
