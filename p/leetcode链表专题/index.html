<!DOCTYPE html>
<html lang="en-us">
    <head><meta charset='utf-8'>
<meta name='viewport' content='width=device-width, initial-scale=1'><meta name='description' content='合并两个有序链表 leetcode链接
今天重做这道题, 发现之前的代码写的太糟糕了(虽然这次也一般).
刚好这一段可以用在排序链表那里.
空间复杂度为O(1).
在这道题上, 我get到的收获是这种方法的空间复杂度为O(1). 而我之前经常写创建一个新的链表, 然后这个链表上又新建一个个值, 导致复杂度为O(n). 但其实现在的O(1)的代码跟O(n)的很像, 区别在于, O(1)的不是新建值然后添加到链表, 而是直接指向旧的链表里的结点. 这样就没有额外的更多开销了.
#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;using namespace std; struct ListNode { int val; ListNode* next; ListNode(int v) { val = v; next = NULL; } }; ListNode* vec2list(vector&amp;lt;int&amp;gt; vec) { ListNode* head = new ListNode(0); ListNode* start = head; for (auto v : vec) { head-&amp;gt;next = new ListNode(v); head = head-&amp;gt;next; } return start-&amp;gt;next; } ListNode* mergeList(ListNode *left, ListNode *right) { ListNode *head = new ListNode(0); ListNode *start = head; while (left !'><title>Leetcode链表专题</title>

<link rel='canonical' href='https://example.com/p/leetcode%E9%93%BE%E8%A1%A8%E4%B8%93%E9%A2%98/'>

<link rel="stylesheet" href="/scss/style.min.css"><meta property='og:title' content='Leetcode链表专题'>
<meta property='og:description' content='合并两个有序链表 leetcode链接
今天重做这道题, 发现之前的代码写的太糟糕了(虽然这次也一般).
刚好这一段可以用在排序链表那里.
空间复杂度为O(1).
在这道题上, 我get到的收获是这种方法的空间复杂度为O(1). 而我之前经常写创建一个新的链表, 然后这个链表上又新建一个个值, 导致复杂度为O(n). 但其实现在的O(1)的代码跟O(n)的很像, 区别在于, O(1)的不是新建值然后添加到链表, 而是直接指向旧的链表里的结点. 这样就没有额外的更多开销了.
#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;using namespace std; struct ListNode { int val; ListNode* next; ListNode(int v) { val = v; next = NULL; } }; ListNode* vec2list(vector&amp;lt;int&amp;gt; vec) { ListNode* head = new ListNode(0); ListNode* start = head; for (auto v : vec) { head-&amp;gt;next = new ListNode(v); head = head-&amp;gt;next; } return start-&amp;gt;next; } ListNode* mergeList(ListNode *left, ListNode *right) { ListNode *head = new ListNode(0); ListNode *start = head; while (left !'>
<meta property='og:url' content='https://example.com/p/leetcode%E9%93%BE%E8%A1%A8%E4%B8%93%E9%A2%98/'>
<meta property='og:site_name' content='Example Site'>
<meta property='og:type' content='article'><meta property='article:section' content='Post' /><meta property='article:tag' content='链表' /><meta property='article:published_time' content='2020-04-02T10:41:45&#43;08:00'/><meta property='article:modified_time' content='2020-04-02T10:41:45&#43;08:00'/>
<meta name="twitter:title" content="Leetcode链表专题">
<meta name="twitter:description" content="合并两个有序链表 leetcode链接
今天重做这道题, 发现之前的代码写的太糟糕了(虽然这次也一般).
刚好这一段可以用在排序链表那里.
空间复杂度为O(1).
在这道题上, 我get到的收获是这种方法的空间复杂度为O(1). 而我之前经常写创建一个新的链表, 然后这个链表上又新建一个个值, 导致复杂度为O(n). 但其实现在的O(1)的代码跟O(n)的很像, 区别在于, O(1)的不是新建值然后添加到链表, 而是直接指向旧的链表里的结点. 这样就没有额外的更多开销了.
#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;using namespace std; struct ListNode { int val; ListNode* next; ListNode(int v) { val = v; next = NULL; } }; ListNode* vec2list(vector&amp;lt;int&amp;gt; vec) { ListNode* head = new ListNode(0); ListNode* start = head; for (auto v : vec) { head-&amp;gt;next = new ListNode(v); head = head-&amp;gt;next; } return start-&amp;gt;next; } ListNode* mergeList(ListNode *left, ListNode *right) { ListNode *head = new ListNode(0); ListNode *start = head; while (left !">
    </head>
    <body class="
    article-page has-toc
">
    <script>
        (function() {
            const colorSchemeKey = 'StackColorScheme';
            if(!localStorage.getItem(colorSchemeKey)){
                localStorage.setItem(colorSchemeKey, "auto");
            }
        })();
    </script><script>
    (function() {
        const colorSchemeKey = 'StackColorScheme';
        const colorSchemeItem = localStorage.getItem(colorSchemeKey);
        const supportDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches === true;

        if (colorSchemeItem == 'dark' || colorSchemeItem === 'auto' && supportDarkMode) {
            

            document.documentElement.dataset.scheme = 'dark';
        } else {
            document.documentElement.dataset.scheme = 'light';
        }
    })();
</script>
<div class="container main-container flex 
    
        extended
    
">
    
        <div id="article-toolbar">
            <a href="https://example.com" class="back-home">
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-chevron-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <polyline points="15 6 9 12 15 18" />
</svg>



                <span>Back</span>
            </a>
        </div>
    
<main class="main full-width">
    <article class="main-article">
    <header class="article-header">

    <div class="article-details">
    
    <header class="article-category">
        
            <a href="/categories/%E7%AE%97%E6%B3%95/" >
                算法
            </a>
        
    </header>
    

    <h2 class="article-title">
        <a href="/p/leetcode%E9%93%BE%E8%A1%A8%E4%B8%93%E9%A2%98/">Leetcode链表专题</a>
    </h2>

    

    
    <footer class="article-time">
        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <path d="M11.795 21h-6.795a2 2 0 0 1 -2 -2v-12a2 2 0 0 1 2 -2h12a2 2 0 0 1 2 2v4" />
  <circle cx="18" cy="18" r="4" />
  <path d="M15 3v4" />
  <path d="M7 3v4" />
  <path d="M3 11h16" />
  <path d="M18 16.496v1.504l1 1" />
</svg>
                <time class="article-time--published">Apr 02, 2020</time>
            </div>
        

        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <polyline points="12 7 12 12 15 15" />
</svg>



                <time class="article-time--reading">
                    10 minute read
                </time>
            </div>
        
    </footer>
    
</div>
</header>

    <section class="article-content">
    <h2 id="合并两个有序链表">合并两个有序链表</h2>
<p><a class="link" href="https://leetcode-cn.com/problems/merge-two-sorted-lists/"  target="_blank" rel="noopener"
    >leetcode链接</a></p>
<p>今天重做这道题, 发现之前的代码写的太糟糕了(虽然这次也一般).</p>
<p>刚好这一段可以用在排序链表那里.</p>
<p>空间复杂度为O(1).</p>
<p>在这道题上, 我get到的收获是这种方法的空间复杂度为O(1). 而我之前经常写创建一个新的链表, 然后这个链表上又新建一个个值, 导致复杂度为O(n). 但其实现在的O(1)的代码跟O(n)的很像, 区别在于, O(1)的不是新建值然后添加到链表, 而是直接指向旧的链表里的结点. 这样就没有额外的更多开销了.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="k">struct</span> <span class="nc">ListNode</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">val</span><span class="p">;</span>
    <span class="n">ListNode</span><span class="o">*</span> <span class="n">next</span><span class="p">;</span>
    <span class="n">ListNode</span><span class="p">(</span><span class="kt">int</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">val</span>  <span class="o">=</span> <span class="n">v</span><span class="p">;</span>
        <span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="n">ListNode</span><span class="o">*</span> <span class="nf">vec2list</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">vec</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">ListNode</span><span class="o">*</span> <span class="n">head</span>  <span class="o">=</span> <span class="k">new</span> <span class="n">ListNode</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
    <span class="n">ListNode</span><span class="o">*</span> <span class="n">start</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">v</span> <span class="p">:</span> <span class="n">vec</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ListNode</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
        <span class="n">head</span>       <span class="o">=</span> <span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">start</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">ListNode</span><span class="o">*</span> <span class="nf">mergeList</span><span class="p">(</span><span class="n">ListNode</span> <span class="o">*</span><span class="n">left</span><span class="p">,</span> <span class="n">ListNode</span> <span class="o">*</span><span class="n">right</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">ListNode</span> <span class="o">*</span><span class="n">head</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ListNode</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
    <span class="n">ListNode</span> <span class="o">*</span><span class="n">start</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">left</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">right</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">left</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">&lt;=</span> <span class="n">right</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">left</span><span class="p">;</span>
            <span class="n">left</span> <span class="o">=</span> <span class="n">left</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">right</span><span class="p">;</span>
            <span class="n">right</span> <span class="o">=</span> <span class="n">right</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">head</span> <span class="o">=</span> <span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">left</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="n">swap</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">);</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">left</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">left</span><span class="p">;</span>
        <span class="n">left</span> <span class="o">=</span> <span class="n">left</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="n">head</span> <span class="o">=</span> <span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">start</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">vec1</span><span class="p">({</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">9</span><span class="p">}),</span> <span class="n">vec2</span><span class="p">({</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">});</span>
    <span class="n">ListNode</span> <span class="o">*</span><span class="n">left</span> <span class="o">=</span> <span class="n">vec2list</span><span class="p">(</span><span class="n">vec1</span><span class="p">),</span> <span class="o">*</span><span class="n">right</span> <span class="o">=</span> <span class="n">vec2list</span><span class="p">(</span><span class="n">vec2</span><span class="p">);</span>
    <span class="n">ListNode</span> <span class="o">*</span><span class="n">newList</span> <span class="o">=</span> <span class="n">mergeList</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><h2 id="合并k个有序链表">合并k个有序链表</h2>
<p>k个怎么合并? 我使用了优先队列(最小堆)</p>
<p>首先将k个链表的头部压入队列中, 之后每次从队列中pop一个值, 然后将对应的链表的下一个值更新队列. 这样每次队列中弹出的值就是当前最小值.</p>
<p>维护优先队列, 队列中同时最多有k个值, 因此空间复杂度为O(k), 时间复杂度为O(nlogk)</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">ListNode</span><span class="o">*</span> <span class="n">mergeKLists</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">ListNode</span><span class="o">*&gt;&amp;</span> <span class="n">lists</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">priority_queue</span><span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="o">&gt;</span><span class="p">,</span> <span class="n">greater</span><span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">k_heap</span><span class="p">;</span>
        <span class="n">ListNode</span><span class="o">*</span> <span class="n">res</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ListNode</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
        <span class="n">ListNode</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="n">res</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">lists</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">lists</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">k_heap</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">make_pair</span><span class="p">(</span><span class="n">lists</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">,</span> <span class="n">i</span><span class="p">));</span>
                <span class="n">lists</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">lists</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">k_heap</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
            <span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">top_node</span> <span class="o">=</span> <span class="n">k_heap</span><span class="p">.</span><span class="n">top</span><span class="p">();</span>
            <span class="n">k_heap</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
            <span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ListNode</span><span class="p">(</span><span class="n">top_node</span><span class="p">.</span><span class="n">first</span><span class="p">);</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
            
            <span class="k">if</span> <span class="p">(</span><span class="n">lists</span><span class="p">[</span><span class="n">top_node</span><span class="p">.</span><span class="n">second</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">k_heap</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">make_pair</span><span class="p">(</span><span class="n">lists</span><span class="p">[</span><span class="n">top_node</span><span class="p">.</span><span class="n">second</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">,</span> <span class="n">top_node</span><span class="p">.</span><span class="n">second</span><span class="p">));</span>
                <span class="n">lists</span><span class="p">[</span><span class="n">top_node</span><span class="p">.</span><span class="n">second</span><span class="p">]</span> <span class="o">=</span> <span class="n">lists</span><span class="p">[</span><span class="n">top_node</span><span class="p">.</span><span class="n">second</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div><h2 id="排序链表">排序链表</h2>
<p><a class="link" href="https://leetcode-cn.com/problems/sort-list/"  target="_blank" rel="noopener"
    >leetcode 链接</a></p>
<p>刚开始我写了一版归并排序, 空间复杂度是O(nlogn)的, 也遇到了很多的问题. 总的来说是因为自己总是遗忘一些链表的特性, 所以debug了很久.</p>
<p>下面是我的一些教训总结</p>
<ol>
<li>
<p>总是把变化了的指针依然当作它的头节点指针, 然而他分明是 head = head-&gt;next 了</p>
</li>
<li>
<p>合并的时候想当然地把 head == NULL 当作条件, 但是其实我是在这个链表里面合并, 终止条件不是NULL, 而是另一半地起始地址</p>
</li>
</ol>
<p>下面有些函数是来辅助debug的</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="k">struct</span> <span class="nc">List</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">val</span><span class="p">;</span>
    <span class="n">List</span><span class="o">*</span> <span class="n">next</span><span class="p">;</span>
    <span class="n">List</span><span class="p">(</span><span class="kt">int</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">val</span>  <span class="o">=</span> <span class="n">v</span><span class="p">;</span>
        <span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="nf">list2vec</span><span class="p">(</span><span class="n">List</span><span class="o">*</span> <span class="n">head</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">debug_vec</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">debug_vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">);</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">head</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; &#34;</span><span class="p">;</span>
        <span class="n">head</span> <span class="o">=</span> <span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="n">i</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">List</span><span class="o">*</span> <span class="nf">listSort</span><span class="p">(</span><span class="n">List</span><span class="o">*</span> <span class="n">mylist</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="k">return</span> <span class="n">mylist</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">mylist</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">mylist</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="k">return</span> <span class="n">mylist</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">mid</span>    <span class="o">=</span> <span class="n">len</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
    <span class="n">List</span><span class="o">*</span> <span class="n">head</span> <span class="o">=</span> <span class="n">mylist</span><span class="p">;</span>
    <span class="n">List</span> <span class="o">*</span><span class="n">preMylist</span> <span class="o">=</span> <span class="n">mylist</span><span class="p">,</span> <span class="o">*</span><span class="n">preHead</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">i</span>      <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">mid</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">i</span><span class="o">++</span><span class="p">;</span>
        <span class="n">head</span> <span class="o">=</span> <span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">mylist</span> <span class="o">=</span> <span class="n">listSort</span><span class="p">(</span><span class="n">mylist</span><span class="p">,</span> <span class="n">mid</span><span class="p">);</span>
    <span class="n">head</span> <span class="o">=</span> <span class="n">listSort</span><span class="p">(</span><span class="n">head</span><span class="p">,</span> <span class="n">len</span> <span class="o">-</span> <span class="n">mid</span><span class="p">);</span>
    <span class="n">List</span><span class="o">*</span> <span class="n">newList</span> <span class="o">=</span> <span class="k">new</span> <span class="n">List</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
    <span class="n">List</span><span class="o">*</span> <span class="n">newHead</span> <span class="o">=</span> <span class="n">newList</span><span class="p">;</span>

    <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="n">mid</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="n">len</span> <span class="o">-</span> <span class="n">mid</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="k">while</span> <span class="p">(</span><span class="n">x</span> <span class="o">&lt;</span> <span class="n">left</span> <span class="o">&amp;&amp;</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="n">right</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">&lt;=</span> <span class="n">mylist</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">newList</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="k">new</span> <span class="n">List</span><span class="p">(</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">);</span>
            <span class="n">newList</span>       <span class="o">=</span> <span class="n">newList</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
            <span class="n">head</span>          <span class="o">=</span> <span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
            <span class="n">y</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">newList</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="k">new</span> <span class="n">List</span><span class="p">(</span><span class="n">mylist</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">);</span>
            <span class="n">newList</span>       <span class="o">=</span> <span class="n">newList</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
            <span class="n">mylist</span>        <span class="o">=</span> <span class="n">mylist</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
            <span class="n">x</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">==</span> <span class="n">left</span> <span class="o">&amp;&amp;</span> <span class="n">y</span> <span class="o">!=</span> <span class="n">right</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">y</span> <span class="o">&lt;</span> <span class="n">right</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">newList</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="k">new</span> <span class="n">List</span><span class="p">(</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">);</span>
            <span class="n">newList</span>       <span class="o">=</span> <span class="n">newList</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
            <span class="n">head</span>          <span class="o">=</span> <span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
            <span class="n">y</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">!=</span> <span class="n">left</span> <span class="o">&amp;&amp;</span> <span class="n">y</span> <span class="o">==</span> <span class="n">right</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">x</span> <span class="o">&lt;</span> <span class="n">left</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">newList</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="k">new</span> <span class="n">List</span><span class="p">(</span><span class="n">mylist</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">);</span>
            <span class="n">newList</span>       <span class="o">=</span> <span class="n">newList</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
            <span class="n">mylist</span>        <span class="o">=</span> <span class="n">mylist</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
            <span class="n">x</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">mylist</span> <span class="o">=</span> <span class="n">newHead</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
    <span class="n">list2vec</span><span class="p">(</span><span class="n">mylist</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">mylist</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">List</span><span class="o">*</span> <span class="nf">vec2list</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">vec</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">List</span><span class="o">*</span> <span class="n">head</span>  <span class="o">=</span> <span class="k">new</span> <span class="n">List</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
    <span class="n">List</span><span class="o">*</span> <span class="n">start</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">v</span> <span class="p">:</span> <span class="n">vec</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="k">new</span> <span class="n">List</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
        <span class="n">head</span>       <span class="o">=</span> <span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">start</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">vec</span><span class="p">({</span><span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">});</span>
    <span class="n">List</span><span class="o">*</span> <span class="n">head</span> <span class="o">=</span> <span class="n">vec2list</span><span class="p">(</span><span class="n">vec</span><span class="p">);</span>
    <span class="n">head</span>       <span class="o">=</span> <span class="n">listSort</span><span class="p">(</span><span class="n">head</span><span class="p">,</span> <span class="n">vec</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">head</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">head</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39; &#39;</span><span class="p">;</span>
        <span class="n">head</span> <span class="o">=</span> <span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>又写了一版空间复杂度O(1)的. 这个版本中使用快慢指针法将链表分割为两段. 使用了合并有序链表相同的代码段.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="cm">/**
</span><span class="cm"> * 空间复杂度O(1)的版本
</span><span class="cm"> */</span>

<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="k">struct</span> <span class="nc">ListNode</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">val</span><span class="p">;</span>
    <span class="n">ListNode</span><span class="o">*</span> <span class="n">next</span><span class="p">;</span>
    <span class="n">ListNode</span><span class="p">(</span><span class="kt">int</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">val</span>  <span class="o">=</span> <span class="n">v</span><span class="p">;</span>
        <span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="nf">list2vec</span><span class="p">(</span><span class="n">ListNode</span><span class="o">*</span> <span class="n">head</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">debug_vec</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">head</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">debug_vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">);</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">head</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; &#34;</span><span class="p">;</span>
        <span class="n">head</span> <span class="o">=</span> <span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">ListNode</span><span class="o">*</span> <span class="nf">mergeList</span><span class="p">(</span><span class="n">ListNode</span><span class="o">*</span> <span class="n">left</span><span class="p">,</span> <span class="n">ListNode</span><span class="o">*</span> <span class="n">right</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">ListNode</span><span class="o">*</span> <span class="n">head</span>  <span class="o">=</span> <span class="k">new</span> <span class="n">ListNode</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
    <span class="n">ListNode</span><span class="o">*</span> <span class="n">start</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">left</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">right</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">left</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">&lt;=</span> <span class="n">right</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">left</span><span class="p">;</span>
            <span class="n">left</span>       <span class="o">=</span> <span class="n">left</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">right</span><span class="p">;</span>
            <span class="n">right</span>      <span class="o">=</span> <span class="n">right</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">head</span> <span class="o">=</span> <span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">left</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="n">swap</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">);</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">left</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">left</span><span class="p">;</span>
        <span class="n">left</span> <span class="o">=</span> <span class="n">left</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="n">head</span> <span class="o">=</span> <span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">start</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">ListNode</span><span class="o">*</span> <span class="nf">listSort</span><span class="p">(</span><span class="n">ListNode</span><span class="o">*</span> <span class="n">mylist</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">mylist</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">mylist</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="k">return</span> <span class="n">mylist</span><span class="p">;</span>
    <span class="c1">// 快慢指针法求中点
</span><span class="c1"></span>    <span class="n">ListNode</span> <span class="o">*</span><span class="n">slow</span> <span class="o">=</span> <span class="n">mylist</span><span class="p">,</span> <span class="o">*</span><span class="n">fast</span> <span class="o">=</span> <span class="n">mylist</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">,</span> <span class="o">*</span><span class="n">last</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">fast</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">last</span> <span class="o">=</span> <span class="n">slow</span><span class="p">;</span>
        <span class="n">slow</span> <span class="o">=</span> <span class="n">slow</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">fast</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
            <span class="n">fast</span> <span class="o">=</span> <span class="n">fast</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="k">else</span>
            <span class="n">fast</span> <span class="o">=</span> <span class="n">fast</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">// 分割链表
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">last</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">last</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">ListNode</span> <span class="o">*</span><span class="n">left</span> <span class="o">=</span> <span class="n">mylist</span><span class="p">,</span> <span class="o">*</span><span class="n">right</span> <span class="o">=</span> <span class="n">slow</span><span class="p">;</span>

    <span class="n">left</span>  <span class="o">=</span> <span class="n">listSort</span><span class="p">(</span><span class="n">left</span><span class="p">);</span>
    <span class="n">right</span> <span class="o">=</span> <span class="n">listSort</span><span class="p">(</span><span class="n">right</span><span class="p">);</span>

    <span class="n">list2vec</span><span class="p">(</span><span class="n">left</span><span class="p">);</span>
    <span class="n">list2vec</span><span class="p">(</span><span class="n">right</span><span class="p">);</span>

    <span class="n">ListNode</span> <span class="o">*</span><span class="n">newList</span> <span class="o">=</span> <span class="n">mergeList</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">);</span>
    
    <span class="k">return</span> <span class="n">newList</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 快速构造链表的方法
</span><span class="c1"></span><span class="n">ListNode</span><span class="o">*</span> <span class="nf">vec2list</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">vec</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">ListNode</span><span class="o">*</span> <span class="n">head</span>  <span class="o">=</span> <span class="k">new</span> <span class="n">ListNode</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
    <span class="n">ListNode</span><span class="o">*</span> <span class="n">start</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">v</span> <span class="p">:</span> <span class="n">vec</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ListNode</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
        <span class="n">head</span>       <span class="o">=</span> <span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">start</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">vec</span><span class="p">({</span><span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">});</span>
    <span class="n">ListNode</span><span class="o">*</span> <span class="n">head</span> <span class="o">=</span> <span class="n">listSort</span><span class="p">(</span><span class="n">vec2list</span><span class="p">(</span><span class="n">vec</span><span class="p">));</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;order:</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">head</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">head</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39; &#39;</span><span class="p">;</span>
        <span class="n">head</span> <span class="o">=</span> <span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><h2 id="分隔链表">分隔链表</h2>
<p><a class="link" href="[%e5%88%86%e5%89%b2%e9%93%be%e8%a1%a8]%28https://leetcode-cn.com/problems/partition-list-lcci/%29" >leetcode链接</a></p>
<blockquote>
<p>编写程序以 x 为基准分割链表，使得所有小于 x 的节点排在大于或等于 x 的节点之前。如果链表中包含 x，x 只需出现在小于 x 的元素之后(如下所示)。分割元素 x 只需处于“右半部分”即可，其不需要被置于左右两部分之间。</p>
<pre tabindex="0"><code>输入: head = 3-&gt;5-&gt;8-&gt;5-&gt;10-&gt;2-&gt;1, x = 5
输出: 3-&gt;1-&gt;2-&gt;10-&gt;5-&gt;5-&gt;8
</code></pre><p>来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/partition-list-lcci
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>这道题虽然是中等题, 但其实很简单. 初看还以为是类似快排的分割, 再看没想到更简单.</p>
<p><strong>只需要将所有比x小的数移出来, 建立新的链表, 然后再连接原链表</strong></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="cm">/**
</span><span class="cm"> * Definition for singly-linked list.
</span><span class="cm"> * struct ListNode {
</span><span class="cm"> *     int val;
</span><span class="cm"> *     ListNode *next;
</span><span class="cm"> *     ListNode(int x) : val(x), next(NULL) {}
</span><span class="cm"> * };
</span><span class="cm"> */</span>
<span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="c1">// 只需要将所有比x小的数移出来, 建立新的链表, 然后再连接原链表
</span><span class="c1"></span>    <span class="n">ListNode</span><span class="o">*</span> <span class="n">partition</span><span class="p">(</span><span class="n">ListNode</span><span class="o">*</span> <span class="n">head</span><span class="p">,</span> <span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">ListNode</span> <span class="o">*</span><span class="n">start</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ListNode</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
        <span class="n">start</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
        <span class="n">ListNode</span> <span class="o">*</span><span class="n">last</span> <span class="o">=</span> <span class="n">start</span><span class="p">,</span> <span class="o">*</span><span class="n">now</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
        <span class="n">ListNode</span> <span class="o">*</span><span class="n">less</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ListNode</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
        <span class="n">ListNode</span> <span class="o">*</span><span class="n">headLess</span> <span class="o">=</span> <span class="n">less</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">now</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">now</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">&gt;=</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">now</span> <span class="o">=</span> <span class="n">now</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
                <span class="n">last</span> <span class="o">=</span> <span class="n">last</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="n">less</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">now</span><span class="p">;</span>
                <span class="n">now</span> <span class="o">=</span> <span class="n">now</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
                <span class="n">last</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">now</span><span class="p">;</span>
                <span class="n">less</span> <span class="o">=</span> <span class="n">less</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="n">less</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">start</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">headLess</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div><h2 id="倒数第k个结点">倒数第k个结点</h2>
<blockquote>
<p>输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。例如，一个链表有6个节点，从头节点开始，它们的值依次是1、2、3、4、5、6。这个链表的倒数第3个节点是值为4的节点。</p>
<p>示例：</p>
<p>给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 k = 2.</p>
<p>返回链表 4-&gt;5.</p>
<p>来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>这道题还挺有意思, 要想知道倒数第k个结点, 只需要用两个指针, 第一个先走k步, 然后同步走. 慢的那个最后就是倒数第k个结点了.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">ListNode</span><span class="o">*</span> <span class="n">getKthFromEnd</span><span class="p">(</span><span class="n">ListNode</span><span class="o">*</span> <span class="n">head</span><span class="p">,</span> <span class="kt">int</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">ListNode</span> <span class="o">*</span><span class="n">start</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ListNode</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
        <span class="n">start</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
        <span class="n">ListNode</span> <span class="o">*</span><span class="n">slow</span> <span class="o">=</span> <span class="n">start</span><span class="p">,</span> <span class="o">*</span><span class="n">fast</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">k</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">fast</span> <span class="o">=</span> <span class="n">fast</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">fast</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">fast</span> <span class="o">=</span> <span class="n">fast</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
            <span class="n">slow</span> <span class="o">=</span> <span class="n">slow</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">slow</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div><h2 id="环形链表">环形链表</h2>
<p><a class="link" href="https://leetcode-cn.com/problems/linked-list-cycle/"  target="_blank" rel="noopener"
    >leetcode链接</a></p>
<p>这道题只需要判断是否有环, 而不需要判断环入口的地址.</p>
<p>一道非常经典的题目, 双指针的方法比较妙. 有多种解法.</p>
<ol>
<li>
<p>hashTable解法. hashTable的复杂度为O(1)</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="cm">/**
</span><span class="cm"> * Definition for singly-linked list.
</span><span class="cm"> * struct ListNode {
</span><span class="cm"> *     int val;
</span><span class="cm"> *     ListNode *next;
</span><span class="cm"> *     ListNode(int x) : val(x), next(NULL) {}
</span><span class="cm"> * };
</span><span class="cm"> */</span>
<span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="kt">bool</span> <span class="n">hasCycle</span><span class="p">(</span><span class="n">ListNode</span> <span class="o">*</span><span class="n">head</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">ListNode</span><span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">addr</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">head</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">addr</span><span class="p">[</span><span class="n">head</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
            <span class="n">addr</span><span class="p">[</span><span class="n">head</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
            <span class="n">head</span> <span class="o">=</span> <span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></li>
<li>
<p>双指针(快慢指针)解法: 一个一次走一步, 一个一次走两步, 走到他们的值(指向的地址值)相等了, 那就是有环了.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="kt">bool</span> <span class="n">hasCycle</span><span class="p">(</span><span class="n">ListNode</span> <span class="o">*</span><span class="n">head</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">ListNode</span> <span class="o">*</span><span class="n">slow</span> <span class="o">=</span> <span class="n">head</span><span class="p">,</span> <span class="o">*</span><span class="n">fast</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">fast</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">slow</span> <span class="o">=</span> <span class="n">slow</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">fast</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
            <span class="n">fast</span> <span class="o">=</span> <span class="n">fast</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">slow</span> <span class="o">==</span> <span class="n">fast</span><span class="p">)</span> <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></li>
</ol>
<h2 id="环形链表2">环形链表2</h2>
<p><a class="link" href="https://leetcode-cn.com/problems/linked-list-cycle-ii/"  target="_blank" rel="noopener"
    >leetcode链接</a></p>
<p>这个环形链表要求找出是第一个结点是环的开始(也就是tail结点指向的结点)</p>
<p>同样的可以用hashTable来做, 就不放代码了.</p>
<p>这道题用双指针法非常妙. 方法就是, 当快慢指针相遇之后, 将快指针放到开头, 然后同时一步一步向前, 第二次相遇点就是他们环的起点了.</p>
<p><a class="link" href="https://leetcode-cn.com/problems/linked-list-cycle-ii/solution/linked-list-cycle-ii-kuai-man-zhi-zhen-shuang-zhi-/"  target="_blank" rel="noopener"
    >这篇题解很好地证明了原因</a></p>
<p>代码</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">ListNode</span> <span class="o">*</span><span class="n">detectCycle</span><span class="p">(</span><span class="n">ListNode</span> <span class="o">*</span><span class="n">head</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">ListNode</span> <span class="o">*</span><span class="n">fast</span> <span class="o">=</span> <span class="n">head</span><span class="p">,</span> <span class="o">*</span><span class="n">slow</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">fast</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">fast</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
            <span class="n">fast</span> <span class="o">=</span> <span class="n">fast</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
            <span class="n">slow</span> <span class="o">=</span> <span class="n">slow</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">fast</span> <span class="o">==</span> <span class="n">slow</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">fast</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="n">fast</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">fast</span> <span class="o">!=</span> <span class="n">slow</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">fast</span> <span class="o">=</span> <span class="n">fast</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
            <span class="n">slow</span> <span class="o">=</span> <span class="n">slow</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">fast</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div><h2 id="删除排序链表中的重复元素">删除排序链表中的重复元素</h2>
<p><a class="link" href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/"  target="_blank" rel="noopener"
    >leetcode链接</a></p>
<p>一道简单题, 链表是有序的. 主要考察一些链表的操作.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">ListNode</span><span class="o">*</span> <span class="n">deleteDuplicates</span><span class="p">(</span><span class="n">ListNode</span><span class="o">*</span> <span class="n">head</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">ListNode</span> <span class="o">*</span><span class="n">start</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ListNode</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
        <span class="n">start</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
        <span class="n">ListNode</span> <span class="o">*</span><span class="n">last</span> <span class="o">=</span> <span class="n">start</span><span class="p">,</span> <span class="o">*</span><span class="n">now</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">now</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">now</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">now</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">==</span> <span class="n">now</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">last</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">now</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
                <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                    <span class="n">last</span> <span class="o">=</span> <span class="n">now</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>
            <span class="n">now</span> <span class="o">=</span> <span class="n">now</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">start</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div><h2 id="删除排序链表中的重复元素2">删除排序链表中的重复元素2</h2>
<p><a class="link" href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/"  target="_blank" rel="noopener"
    >leetcode链接</a></p>
<p>和上一题的区别是, 如果一个数重复出现了, 那么全部删掉, 一个都不保留</p>
<p>只需要加一个<code>flag</code>标志, 表示是否是重复的元素. 如果是, 那么在到达下一个新的值的结点的时候删除这个结点.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">ListNode</span><span class="o">*</span> <span class="n">deleteDuplicates</span><span class="p">(</span><span class="n">ListNode</span><span class="o">*</span> <span class="n">head</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">ListNode</span> <span class="o">*</span><span class="n">start</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ListNode</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
        <span class="n">start</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
        <span class="n">ListNode</span> <span class="o">*</span><span class="n">last</span> <span class="o">=</span> <span class="n">start</span><span class="p">,</span> <span class="o">*</span><span class="n">now</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
        <span class="kt">bool</span> <span class="n">flag</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>  <span class="c1">// 表示重复标志
</span><span class="c1"></span>        <span class="k">while</span> <span class="p">(</span><span class="n">now</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">now</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">now</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">==</span> <span class="n">now</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">last</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">now</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
                    <span class="n">flag</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
                <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">flag</span><span class="p">)</span> <span class="n">last</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">now</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
                    <span class="k">else</span> <span class="n">last</span> <span class="o">=</span> <span class="n">now</span><span class="p">;</span>
                    <span class="n">flag</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">flag</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">last</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">now</span> <span class="o">=</span> <span class="n">now</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">start</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div><h2 id="奇偶链表">奇偶链表</h2>
<p><a class="link" href="https://leetcode-cn.com/problems/odd-even-linked-list/"  target="_blank" rel="noopener"
    >leetcode链接</a></p>
<p>分别建立奇数偶数的头部, 然后指向奇数和偶数索引的结点.</p>
<p>需要注意在偶数结束的时候, 要将它的最后一个结点指向NULL. 否则会形成环.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">ListNode</span><span class="o">*</span> <span class="n">oddEvenList</span><span class="p">(</span><span class="n">ListNode</span><span class="o">*</span> <span class="n">head</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">ListNode</span> <span class="o">*</span><span class="n">ji</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ListNode</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="o">*</span><span class="n">ou</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ListNode</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
        <span class="n">ListNode</span> <span class="o">*</span><span class="n">preJi</span> <span class="o">=</span> <span class="n">ji</span><span class="p">,</span> <span class="o">*</span><span class="n">preOu</span> <span class="o">=</span> <span class="n">ou</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">head</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">%</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">ji</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
                <span class="n">ji</span> <span class="o">=</span> <span class="n">ji</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="n">ou</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
                <span class="n">ou</span> <span class="o">=</span> <span class="n">ou</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">head</span> <span class="o">=</span> <span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">ou</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="n">ji</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">preOu</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">preJi</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div><h2 id="重排链表">重排链表</h2>
<blockquote>
<p>给定一个单链表 L：L0→L1→…→Ln-1→Ln ，
将其重新排列后变为： L0→Ln→L1→Ln-1→L2→Ln-2→…</p>
<p>你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p>
<p>示例 1:</p>
<p>给定链表 1-&gt;2-&gt;3-&gt;4, 重新排列为 1-&gt;4-&gt;2-&gt;3.
示例 2:</p>
<p>给定链表 1-&gt;2-&gt;3-&gt;4-&gt;5, 重新排列为 1-&gt;5-&gt;2-&gt;4-&gt;3.</p>
<p>来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/reorder-list
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>把所有链表结点的值存到vector中, 然后两个指针, 一个从头一个从尾, 分别遍历过来.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="kt">void</span> <span class="n">reorderList</span><span class="p">(</span><span class="n">ListNode</span><span class="o">*</span> <span class="n">head</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">head</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
        <span class="n">ListNode</span> <span class="o">*</span><span class="n">iter</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="n">ListNode</span><span class="o">*&gt;</span> <span class="n">ps</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">iter</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">ps</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">iter</span><span class="p">);</span>
            <span class="n">iter</span> <span class="o">=</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">debug_list</span><span class="p">(</span><span class="n">head</span><span class="p">);</span>
        <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">ps</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">a</span> <span class="o">&lt;</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">ps</span><span class="p">[</span><span class="n">b</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">ps</span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
            <span class="n">ps</span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">ps</span><span class="p">[</span><span class="n">b</span><span class="p">];</span>
            <span class="n">a</span><span class="o">++</span><span class="p">;</span>
            <span class="n">b</span><span class="o">--</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">ps</span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="n">debug_list</span><span class="p">(</span><span class="n">head</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div><p>或者也可以将链表分为左右两半, 然后第二半调用反转链表的方法, 之后合并.</p>
<h2 id="反转链表">反转链表</h2>
<p>这种题是真的烦, 操作太细节了.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">ListNode</span><span class="o">*</span> <span class="n">reverseList</span><span class="p">(</span><span class="n">ListNode</span><span class="o">*</span> <span class="n">head</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">head</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="k">return</span> <span class="n">head</span><span class="p">;</span>
        <span class="n">ListNode</span> <span class="o">*</span><span class="n">toBeZero</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
        <span class="n">ListNode</span><span class="o">*</span> <span class="n">start</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ListNode</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
        <span class="n">start</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
        <span class="n">ListNode</span><span class="o">*</span> <span class="n">pos</span> <span class="o">=</span> <span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">pos</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">ListNode</span> <span class="o">*</span><span class="n">tmp</span> <span class="o">=</span> <span class="n">pos</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
            <span class="n">pos</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">start</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
            <span class="n">start</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">pos</span><span class="p">;</span>
            <span class="n">pos</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">start</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div><h2 id="反转链表2">反转链表2</h2>
<p>[leetcode链接</p>
<p>遍历找出在[m, n]位置的链表, 然后拆分成三段, 调用反转链表函数反转这部分, 再拼接起来.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
   <span class="k">public</span><span class="o">:</span>
    <span class="n">ListNode</span> <span class="o">*</span><span class="n">reverseBetween</span><span class="p">(</span><span class="n">ListNode</span> <span class="o">*</span><span class="n">head</span><span class="p">,</span> <span class="kt">int</span> <span class="n">m</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">head</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">ind</span>       <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">ListNode</span> <span class="o">*</span><span class="n">start</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ListNode</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
        <span class="n">start</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
        <span class="n">ListNode</span> <span class="o">*</span><span class="n">sub</span> <span class="o">=</span> <span class="n">start</span><span class="p">,</span> <span class="o">*</span><span class="n">ano</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">*</span><span class="n">last</span><span class="p">,</span> <span class="o">*</span><span class="n">next</span><span class="p">,</span> <span class="o">*</span><span class="n">last0</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">sub</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">ind</span> <span class="o">==</span> <span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="n">last0</span> <span class="o">=</span> <span class="n">sub</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">ind</span> <span class="o">==</span> <span class="n">m</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">ano</span> <span class="o">=</span> <span class="n">sub</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">ind</span> <span class="o">==</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">last</span> <span class="o">=</span> <span class="n">sub</span><span class="p">;</span>
                <span class="n">next</span> <span class="o">=</span> <span class="n">last</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">ind</span><span class="o">++</span><span class="p">;</span>
            <span class="n">sub</span> <span class="o">=</span> <span class="n">sub</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">last</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="n">ListNode</span> <span class="o">*</span><span class="n">newSub</span> <span class="o">=</span> <span class="n">reverseList</span><span class="p">(</span><span class="n">ano</span><span class="p">);</span>
        <span class="n">last0</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">newSub</span><span class="p">;</span>
        <span class="n">ano</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">start</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// 反转链表
</span><span class="c1"></span>    <span class="n">ListNode</span> <span class="o">*</span><span class="nf">reverseList</span><span class="p">(</span><span class="n">ListNode</span> <span class="o">*</span><span class="n">head</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">head</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="k">return</span> <span class="n">head</span><span class="p">;</span>
        <span class="n">ListNode</span> <span class="o">*</span><span class="n">toBeZero</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
        <span class="n">ListNode</span> <span class="o">*</span><span class="n">start</span>    <span class="o">=</span> <span class="k">new</span> <span class="n">ListNode</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
        <span class="n">start</span><span class="o">-&gt;</span><span class="n">next</span>        <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
        <span class="n">ListNode</span> <span class="o">*</span><span class="n">pos</span>      <span class="o">=</span> <span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">pos</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">ListNode</span> <span class="o">*</span><span class="n">tmp</span> <span class="o">=</span> <span class="n">pos</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
            <span class="n">pos</span><span class="o">-&gt;</span><span class="n">next</span>     <span class="o">=</span> <span class="n">start</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
            <span class="n">start</span><span class="o">-&gt;</span><span class="n">next</span>   <span class="o">=</span> <span class="n">pos</span><span class="p">;</span>
            <span class="n">pos</span>           <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">start</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div><h2 id="k个一组反转链表">k个一组反转链表</h2>
<p>没有按题目要求做到O(1)的空间复杂度, 而是用了vector做辅助.</p>
<p>先将所有结点存起来, 然后分别反转, 再连接起来.</p>
<p>要用到O(1)的空间太细节了啊, debug好久做不出来.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
   <span class="k">public</span><span class="o">:</span>
    <span class="n">ListNode</span> <span class="o">*</span><span class="n">reverseKGroup</span><span class="p">(</span><span class="n">ListNode</span> <span class="o">*</span><span class="n">head</span><span class="p">,</span> <span class="kt">int</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">head</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="n">ListNode</span> <span class="o">*</span><span class="n">pos</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="n">ListNode</span> <span class="o">*&gt;</span> <span class="n">ps</span><span class="p">,</span> <span class="n">allPs</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">pos</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">ps</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">pos</span><span class="p">);</span>
            <span class="n">pos</span> <span class="o">=</span> <span class="n">pos</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">ps</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span>
                <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">ps</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
                <span class="k">while</span> <span class="p">(</span><span class="n">x</span> <span class="o">&lt;</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">swap</span><span class="p">(</span><span class="n">ps</span><span class="p">[</span><span class="n">x</span><span class="p">],</span> <span class="n">ps</span><span class="p">[</span><span class="n">y</span><span class="p">]);</span>
                    <span class="n">x</span><span class="o">++</span><span class="p">,</span> <span class="n">y</span><span class="o">--</span><span class="p">;</span>
                <span class="p">}</span>
                <span class="n">allPs</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">allPs</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">ps</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">ps</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
                <span class="n">ps</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="n">allPs</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">allPs</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">ps</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">ps</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
        
        <span class="n">ListNode</span> <span class="o">*</span><span class="n">start</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ListNode</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="o">*</span><span class="n">loc</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">p</span> <span class="p">:</span> <span class="n">allPs</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">loc</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
            <span class="n">loc</span>       <span class="o">=</span> <span class="n">loc</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">allPs</span><span class="p">.</span><span class="n">back</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">start</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div><h2 id="有序链表转二叉树">有序链表转二叉树</h2>
<blockquote>
<p>给定一个单链表，其中的元素按升序排序，将其转换为高度平衡的二叉搜索树。</p>
<p>本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。</p>
<p>示例:</p>
<p>给定的有序链表： [-10, -3, 0, 5, 9],</p>
<p>一个可能的答案是：[0, -3, 9, -10, null, 5], 它可以表示下面这个高度平衡二叉搜索树：</p>
<pre><code>      0
     / \
   -3   9
   /   /
 -10  5
</code></pre>
<p>来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>这道题的重点在于保持二叉搜索树高度平衡.</p>
<p>刚开始没有严格考虑这一条件, 就直接按照模拟中序遍历的方式, 自底向上地建立搜索树.</p>
<p>后来发现这样会断层, 于是引入了count, 没有剩余可扩展节点了就停止扩展, 而不是一直往最深入扩展. 但是还是错了, 因为树不平衡. 之前count是到它的左子树-1, 右子树-1, 考虑到平均分配, 就给左子树cnt/2, 右子树cnt &ndash; 1 - cnt/2.</p>
<p><strong>下面是实现的代码</strong></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
   <span class="k">public</span><span class="o">:</span>
	<span class="n">TreeNode</span> <span class="o">*</span><span class="n">sortedListToBST</span><span class="p">(</span><span class="n">ListNode</span> <span class="o">*</span><span class="n">head</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">head</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">cnt</span>       <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">ListNode</span> <span class="o">*</span><span class="n">pos</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">pos</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">cnt</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">pos</span> <span class="o">=</span> <span class="n">pos</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">TreeNode</span> <span class="o">*</span><span class="n">ans</span> <span class="o">=</span> <span class="n">build</span><span class="p">(</span><span class="n">head</span><span class="p">,</span> <span class="n">cnt</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ans</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">TreeNode</span> <span class="o">*</span><span class="nf">build</span><span class="p">(</span><span class="n">ListNode</span> <span class="o">*&amp;</span><span class="n">head</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cnt</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">head</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cnt</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">nowCnt</span>     <span class="o">=</span> <span class="n">cnt</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">leftCnt</span> <span class="o">=</span> <span class="n">nowCnt</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">rightCnt</span> <span class="o">=</span> <span class="n">nowCnt</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">leftCnt</span><span class="p">;</span>
		<span class="n">TreeNode</span> <span class="o">*</span><span class="n">left</span> <span class="o">=</span> <span class="n">build</span><span class="p">(</span><span class="n">head</span><span class="p">,</span> <span class="n">leftCnt</span><span class="p">);</span>
		<span class="n">TreeNode</span> <span class="o">*</span><span class="n">root</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TreeNode</span><span class="p">(</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">);</span>
		<span class="n">head</span>            <span class="o">=</span> <span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
		<span class="n">TreeNode</span> <span class="o">*</span><span class="n">right</span> <span class="o">=</span> <span class="n">build</span><span class="p">(</span><span class="n">head</span><span class="p">,</span> <span class="n">rightCnt</span><span class="p">);</span>
		<span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span>      <span class="o">=</span> <span class="n">left</span><span class="p">;</span>
		<span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span>     <span class="o">=</span> <span class="n">right</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">root</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">};</span>
</code></pre></div><p>我这个方法在官方题解中属于中序遍历模拟方法.</p>

</section>


    <footer class="article-footer">
    
    <section class="article-tags">
        
            <a href="/tags/%E9%93%BE%E8%A1%A8/">链表</a>
        
    </section>


    
    <section class="article-copyright">
        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <path d="M14.5 9a3.5 4 0 1 0 0 6" />
</svg>



        <span>Licensed under CC BY-NC-SA 4.0</span>
    </section>
    </footer>


    
</article>

    <aside class="related-contents--wrapper">
    
    
        <h2 class="section-title">Related contents</h2>
        <div class="related-contents">
            <div class="flex article-list--tile">
                
                    
<article class="">
    <a href="/p/%E9%9A%8F%E6%9C%BA%E6%A0%91%E7%94%9F%E6%88%90%E7%AE%97%E6%B3%95-%E5%B0%B1%E6%98%AF%E6%A0%91/">
        
        

        <div class="article-details">
            <h2 class="article-title">随机树生成算法 就是树! </h2>
        </div>
    </a>
</article>
                
                    
<article class="">
    <a href="/p/ida-star%E7%AE%97%E6%B3%95%E8%A7%A3%E5%8D%81%E5%85%AD%E5%AE%AB%E6%A0%BC%E6%8B%BC%E5%9B%BE%E9%97%AE%E9%A2%98/">
        
        

        <div class="article-details">
            <h2 class="article-title">IDA Star算法解十六宫格拼图问题</h2>
        </div>
    </a>
</article>
                
                    
<article class="">
    <a href="/p/%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97/">
        
        

        <div class="article-details">
            <h2 class="article-title">数组中出现次数超过一半的数字</h2>
        </div>
    </a>
</article>
                
                    
<article class="">
    <a href="/p/tarjan%E7%AE%97%E6%B3%95%E7%BC%A9%E7%82%B9-dag%E6%9C%80%E9%95%BF%E8%B7%AF-dp/">
        
        

        <div class="article-details">
            <h2 class="article-title">Tarjan算法缩点&#43;DAG最长路 DP</h2>
        </div>
    </a>
</article>
                
                    
<article class="">
    <a href="/p/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91_%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82%E8%A7%A3%E6%B3%95/">
        
        

        <div class="article-details">
            <h2 class="article-title">斐波那契_矩阵快速幂解法</h2>
        </div>
    </a>
</article>
                
            </div>
        </div>
    
</aside>

     
    
        
    <div class="disqus-container">
    <div id="disqus_thread"></div>
<script type="application/javascript">
    var disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "hugo-theme-stack" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</div>

<style>
    .disqus-container {
        background-color: var(--card-background);
        border-radius: var(--card-border-radius);
        box-shadow: var(--shadow-l1);
        padding: var(--card-padding);
    }
</style>

<script>
    window.addEventListener('onColorSchemeChange', (e) => {
        if (DISQUS) {
            DISQUS.reset({
                reload: true
            });
        }
    })
</script>

    

    <footer class="site-footer">
    <section class="copyright">
        &copy; 
        
            2020 - 
        
        2021 Example Site
    </section>
    
    <section class="powerby">
        Built with <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> <br />
        Theme <b><a href="https://github.com/CaiJimmy/hugo-theme-stack" target="_blank" rel="noopener" data-version="3.2.0">Stack</a></b> designed by <a href="https://jimmycai.com" target="_blank" rel="noopener">Jimmy</a>
    </section>
</footer>


    
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    
    <div class="pswp__bg"></div>

    
    <div class="pswp__scroll-wrap">

        
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                
                
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo="crossorigin="anonymous"
                defer="true"
                >
            </script><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU="crossorigin="anonymous"
                defer="true"
                >
            </script><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.css"integrity="sha256-c0uckgykQ9v5k&#43;IqViZOZKc47Jn7KQil4/MP3ySA3F8="crossorigin="anonymous"
            ><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.css"integrity="sha256-SBLU4vv6CA6lHsZ1XyTdhyjJxCjPif/TRkjnsyGAGnE="crossorigin="anonymous"
            >

            </main>
    
        <aside class="sidebar right-sidebar sticky">
            <section class="widget archives">
                <div class="widget-icon">
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <line x1="5" y1="9" x2="19" y2="9" />
  <line x1="5" y1="15" x2="19" y2="15" />
  <line x1="11" y1="4" x2="7" y2="20" />
  <line x1="17" y1="4" x2="13" y2="20" />
</svg>



                </div>
                <h2 class="widget-title section-title">Table of contents</h2>
                
                <div class="widget--toc">
                    <nav id="TableOfContents">
  <ol>
    <li><a href="#合并两个有序链表">合并两个有序链表</a></li>
    <li><a href="#合并k个有序链表">合并k个有序链表</a></li>
    <li><a href="#排序链表">排序链表</a></li>
    <li><a href="#分隔链表">分隔链表</a></li>
    <li><a href="#倒数第k个结点">倒数第k个结点</a></li>
    <li><a href="#环形链表">环形链表</a></li>
    <li><a href="#环形链表2">环形链表2</a></li>
    <li><a href="#删除排序链表中的重复元素">删除排序链表中的重复元素</a></li>
    <li><a href="#删除排序链表中的重复元素2">删除排序链表中的重复元素2</a></li>
    <li><a href="#奇偶链表">奇偶链表</a></li>
    <li><a href="#重排链表">重排链表</a></li>
    <li><a href="#反转链表">反转链表</a></li>
    <li><a href="#反转链表2">反转链表2</a></li>
    <li><a href="#k个一组反转链表">k个一组反转链表</a></li>
    <li><a href="#有序链表转二叉树">有序链表转二叉树</a></li>
  </ol>
</nav>
                </div>
            </section>
        </aside>
    

        </div>
        <script 
                src="https://cdn.jsdelivr.net/npm/node-vibrant@3.1.5/dist/vibrant.min.js"integrity="sha256-5NovOZc4iwiAWTYIFiIM7DxKUXKWvpVEuMEPLzcm5/g="crossorigin="anonymous"
                defer="false"
                >
            </script><script type="text/javascript" src="/ts/main.js" defer></script>
<script>
    (function () {
        const customFont = document.createElement('link');
        customFont.href = "https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap";

        customFont.type = "text/css";
        customFont.rel = "stylesheet";

        document.head.appendChild(customFont);
    }());
</script>

    </body>
</html>
