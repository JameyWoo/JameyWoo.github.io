<!DOCTYPE html>
<html lang="en-us">
    <head><meta charset='utf-8'>
<meta name='viewport' content='width=device-width, initial-scale=1'><meta name='description' content='概述 本文围绕CMU 15-445中的Tree Indexes一课，对数据库引擎中的索引进行介绍和总结，点击下载课程的slide链接。本文不介绍B&#43;Tree基本结构和操作细节，而是介绍在了解这些之后的比较和思考。
在这节课中，Andy介绍了B&#43;Tree索引以及其后面的B-Tree family，以及其他索引类型，如聚簇索引，倒排索引，覆盖索引，联合索引等。介绍B&#43;Tree占了最大篇幅，除了其基本内容，还详细地分析了B&#43;Tree中leaf node的内容；并且使用PostgreSQL和MySQL进行了索引选择的实验。Andy还介绍了几种索引实现的优化方法，包括前缀压缩，批量插入，pointer swizzling（指针混写）等。
索引分类 索引是数据库存储引擎中非常重要的一个模块，数据Access Methods的内容，即访问方法，顾名思义就是如何访问数据的方法。在数据库层次结构中属于Buffer Pool只上，查询执行器之下的层次。
 image-20211008220207365 
一般而言，有三类索引数据结构，分别是
 hash_table Trees 全文索引  而Trees又有很多类型，如B-Tree家族，Trie Tree（字典树，前缀树），Radix Tree（基数树，Trie的一种变体）；其中以B&#43;Tree为代表的B-Tree家族是最重要的，使用最为广泛的数据结构。
hash_table是一种点查询性能非常高的数据结构，在key-value类型的数据库中如Memcache，Redis使用，其在内存上维护巨大的hash_table，具有非常好的性能。它不适合进行范围查询。
B&#43;Tree B&#43;Tree属于B-Tree家族，而B-Tree最早在1971年提出，衍生出了许多数据结构，如
 B&#43;Tree 1973 IBM 这节课主要介绍这个 B*Tree 1977 B^link-Tree CMU  目前，B&#43;Tree是各种数据库引擎中使用最广泛的数据结构。
B&#43;Tree操作 Andy演示了Insert，Delete，Find三种操作
对于Insert
 https://cmudb.io/btree 演示demo 实际网址 https://www.cs.usfca.edu/~galles/visualization/BPlusTree.html Degree x表示最多x个指针指向下一层, 而一个node最多有x-1个key 空间足够可以直接插入 否则需要拆分节点, 然后影响上面的inner node  Delete
 注意规则, 一个node至少需要M/2-1个entries, 如果少于这个, 就需要进行合并, 这个过程可能会重构整个树 实际上，不需要到达边界后就进行拆分和合并，可以维护一个阈值范围，减少拆分合并次数  在《MySQL技术内幕-InnoDB存储引擎》中，将插入和删除各分为三种情况讨论，我认为总结得很好
插入（根据Leaf Page和Index Page分为三种情况）
  Leaf Page未满 &amp;amp;&amp;amp; Index Page未满'><title>CMU 15-445系列x: 索引</title>

<link rel='canonical' href='https://example.com/p/cmu-15-445%E7%B3%BB%E5%88%97x-%E7%B4%A2%E5%BC%95/'>

<link rel="stylesheet" href="/scss/style.min.css"><meta property='og:title' content='CMU 15-445系列x: 索引'>
<meta property='og:description' content='概述 本文围绕CMU 15-445中的Tree Indexes一课，对数据库引擎中的索引进行介绍和总结，点击下载课程的slide链接。本文不介绍B&#43;Tree基本结构和操作细节，而是介绍在了解这些之后的比较和思考。
在这节课中，Andy介绍了B&#43;Tree索引以及其后面的B-Tree family，以及其他索引类型，如聚簇索引，倒排索引，覆盖索引，联合索引等。介绍B&#43;Tree占了最大篇幅，除了其基本内容，还详细地分析了B&#43;Tree中leaf node的内容；并且使用PostgreSQL和MySQL进行了索引选择的实验。Andy还介绍了几种索引实现的优化方法，包括前缀压缩，批量插入，pointer swizzling（指针混写）等。
索引分类 索引是数据库存储引擎中非常重要的一个模块，数据Access Methods的内容，即访问方法，顾名思义就是如何访问数据的方法。在数据库层次结构中属于Buffer Pool只上，查询执行器之下的层次。
 image-20211008220207365 
一般而言，有三类索引数据结构，分别是
 hash_table Trees 全文索引  而Trees又有很多类型，如B-Tree家族，Trie Tree（字典树，前缀树），Radix Tree（基数树，Trie的一种变体）；其中以B&#43;Tree为代表的B-Tree家族是最重要的，使用最为广泛的数据结构。
hash_table是一种点查询性能非常高的数据结构，在key-value类型的数据库中如Memcache，Redis使用，其在内存上维护巨大的hash_table，具有非常好的性能。它不适合进行范围查询。
B&#43;Tree B&#43;Tree属于B-Tree家族，而B-Tree最早在1971年提出，衍生出了许多数据结构，如
 B&#43;Tree 1973 IBM 这节课主要介绍这个 B*Tree 1977 B^link-Tree CMU  目前，B&#43;Tree是各种数据库引擎中使用最广泛的数据结构。
B&#43;Tree操作 Andy演示了Insert，Delete，Find三种操作
对于Insert
 https://cmudb.io/btree 演示demo 实际网址 https://www.cs.usfca.edu/~galles/visualization/BPlusTree.html Degree x表示最多x个指针指向下一层, 而一个node最多有x-1个key 空间足够可以直接插入 否则需要拆分节点, 然后影响上面的inner node  Delete
 注意规则, 一个node至少需要M/2-1个entries, 如果少于这个, 就需要进行合并, 这个过程可能会重构整个树 实际上，不需要到达边界后就进行拆分和合并，可以维护一个阈值范围，减少拆分合并次数  在《MySQL技术内幕-InnoDB存储引擎》中，将插入和删除各分为三种情况讨论，我认为总结得很好
插入（根据Leaf Page和Index Page分为三种情况）
  Leaf Page未满 &amp;amp;&amp;amp; Index Page未满'>
<meta property='og:url' content='https://example.com/p/cmu-15-445%E7%B3%BB%E5%88%97x-%E7%B4%A2%E5%BC%95/'>
<meta property='og:site_name' content='Example Site'>
<meta property='og:type' content='article'><meta property='article:section' content='Post' /><meta property='article:tag' content='数据库' /><meta property='article:tag' content='CMU 15-445' /><meta property='article:published_time' content='2021-10-08T20:23:55&#43;08:00'/><meta property='article:modified_time' content='2021-10-08T20:23:55&#43;08:00'/>
<meta name="twitter:title" content="CMU 15-445系列x: 索引">
<meta name="twitter:description" content="概述 本文围绕CMU 15-445中的Tree Indexes一课，对数据库引擎中的索引进行介绍和总结，点击下载课程的slide链接。本文不介绍B&#43;Tree基本结构和操作细节，而是介绍在了解这些之后的比较和思考。
在这节课中，Andy介绍了B&#43;Tree索引以及其后面的B-Tree family，以及其他索引类型，如聚簇索引，倒排索引，覆盖索引，联合索引等。介绍B&#43;Tree占了最大篇幅，除了其基本内容，还详细地分析了B&#43;Tree中leaf node的内容；并且使用PostgreSQL和MySQL进行了索引选择的实验。Andy还介绍了几种索引实现的优化方法，包括前缀压缩，批量插入，pointer swizzling（指针混写）等。
索引分类 索引是数据库存储引擎中非常重要的一个模块，数据Access Methods的内容，即访问方法，顾名思义就是如何访问数据的方法。在数据库层次结构中属于Buffer Pool只上，查询执行器之下的层次。
 image-20211008220207365 
一般而言，有三类索引数据结构，分别是
 hash_table Trees 全文索引  而Trees又有很多类型，如B-Tree家族，Trie Tree（字典树，前缀树），Radix Tree（基数树，Trie的一种变体）；其中以B&#43;Tree为代表的B-Tree家族是最重要的，使用最为广泛的数据结构。
hash_table是一种点查询性能非常高的数据结构，在key-value类型的数据库中如Memcache，Redis使用，其在内存上维护巨大的hash_table，具有非常好的性能。它不适合进行范围查询。
B&#43;Tree B&#43;Tree属于B-Tree家族，而B-Tree最早在1971年提出，衍生出了许多数据结构，如
 B&#43;Tree 1973 IBM 这节课主要介绍这个 B*Tree 1977 B^link-Tree CMU  目前，B&#43;Tree是各种数据库引擎中使用最广泛的数据结构。
B&#43;Tree操作 Andy演示了Insert，Delete，Find三种操作
对于Insert
 https://cmudb.io/btree 演示demo 实际网址 https://www.cs.usfca.edu/~galles/visualization/BPlusTree.html Degree x表示最多x个指针指向下一层, 而一个node最多有x-1个key 空间足够可以直接插入 否则需要拆分节点, 然后影响上面的inner node  Delete
 注意规则, 一个node至少需要M/2-1个entries, 如果少于这个, 就需要进行合并, 这个过程可能会重构整个树 实际上，不需要到达边界后就进行拆分和合并，可以维护一个阈值范围，减少拆分合并次数  在《MySQL技术内幕-InnoDB存储引擎》中，将插入和删除各分为三种情况讨论，我认为总结得很好
插入（根据Leaf Page和Index Page分为三种情况）
  Leaf Page未满 &amp;amp;&amp;amp; Index Page未满">
    </head>
    <body class="
    article-page has-toc
">
    <script>
        (function() {
            const colorSchemeKey = 'StackColorScheme';
            if(!localStorage.getItem(colorSchemeKey)){
                localStorage.setItem(colorSchemeKey, "auto");
            }
        })();
    </script><script>
    (function() {
        const colorSchemeKey = 'StackColorScheme';
        const colorSchemeItem = localStorage.getItem(colorSchemeKey);
        const supportDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches === true;

        if (colorSchemeItem == 'dark' || colorSchemeItem === 'auto' && supportDarkMode) {
            

            document.documentElement.dataset.scheme = 'dark';
        } else {
            document.documentElement.dataset.scheme = 'light';
        }
    })();
</script>
<div class="container main-container flex 
    
        extended
    
">
    
        <div id="article-toolbar">
            <a href="https://example.com" class="back-home">
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-chevron-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <polyline points="15 6 9 12 15 18" />
</svg>



                <span>Back</span>
            </a>
        </div>
    
<main class="main full-width">
    <article class="main-article">
    <header class="article-header">

    <div class="article-details">
    
    <header class="article-category">
        
            <a href="/categories/cmu-15-445%E7%B3%BB%E5%88%97/" >
                CMU 15-445系列
            </a>
        
    </header>
    

    <h2 class="article-title">
        <a href="/p/cmu-15-445%E7%B3%BB%E5%88%97x-%E7%B4%A2%E5%BC%95/">CMU 15-445系列x: 索引</a>
    </h2>

    

    
    <footer class="article-time">
        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <path d="M11.795 21h-6.795a2 2 0 0 1 -2 -2v-12a2 2 0 0 1 2 -2h12a2 2 0 0 1 2 2v4" />
  <circle cx="18" cy="18" r="4" />
  <path d="M15 3v4" />
  <path d="M7 3v4" />
  <path d="M3 11h16" />
  <path d="M18 16.496v1.504l1 1" />
</svg>
                <time class="article-time--published">Oct 08, 2021</time>
            </div>
        

        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <polyline points="12 7 12 12 15 15" />
</svg>



                <time class="article-time--reading">
                    2 minute read
                </time>
            </div>
        
    </footer>
    
</div>
</header>

    <section class="article-content">
    <h2 id="概述">概述</h2>
<p>本文围绕CMU 15-445中的Tree Indexes一课，对数据库引擎中的索引进行介绍和总结，<a class="link" href="https://15445.courses.cs.cmu.edu/fall2021/slides/"  target="_blank" rel="noopener"
    >点击下载课程的slide链接</a>。本文不介绍B+Tree基本结构和操作细节，而是介绍在了解这些之后的比较和思考。</p>
<p>在这节课中，Andy介绍了B+Tree索引以及其后面的B-Tree family，以及其他索引类型，如聚簇索引，倒排索引，覆盖索引，联合索引等。介绍B+Tree占了最大篇幅，除了其基本内容，还详细地分析了B+Tree中leaf node的内容；并且使用PostgreSQL和MySQL进行了索引选择的实验。Andy还介绍了几种索引实现的优化方法，包括前缀压缩，批量插入，pointer swizzling（指针混写）等。</p>
<h2 id="索引分类">索引分类</h2>
<p>索引是数据库存储引擎中非常重要的一个模块，数据Access Methods的内容，即访问方法，顾名思义就是如何访问数据的方法。在数据库层次结构中属于Buffer Pool只上，查询执行器之下的层次。</p>
<p><figure 
	>
	<a href="https://raw.githubusercontent.com/JameyWoo/FigureBed/master/hugo_imgs/image-20211008220207365.png" >
		<img src="https://raw.githubusercontent.com/JameyWoo/FigureBed/master/hugo_imgs/image-20211008220207365.png"
			
			
			
			loading="lazy"
			alt="image-20211008220207365">
	</a>
	
	<figcaption>image-20211008220207365</figcaption>
	
</figure></p>
<p>一般而言，有三类索引数据结构，分别是</p>
<ol>
<li>hash_table</li>
<li>Trees</li>
<li>全文索引</li>
</ol>
<p>而Trees又有很多类型，如B-Tree家族，Trie Tree（字典树，前缀树），Radix Tree（基数树，Trie的一种变体）；其中以B+Tree为代表的B-Tree家族是最重要的，使用最为广泛的数据结构。</p>
<p>hash_table是一种点查询性能非常高的数据结构，在key-value类型的数据库中如Memcache，Redis使用，其在内存上维护巨大的hash_table，具有非常好的性能。它不适合进行范围查询。</p>
<h2 id="btree">B+Tree</h2>
<p>B+Tree属于B-Tree家族，而B-Tree最早在1971年提出，衍生出了许多数据结构，如</p>
<ul>
<li>B+Tree 1973 IBM 这节课主要介绍这个</li>
<li>B*Tree 1977</li>
<li>B^link-Tree CMU</li>
</ul>
<p>目前，B+Tree是各种数据库引擎中使用最广泛的数据结构。</p>
<h3 id="btree操作">B+Tree操作</h3>
<p>Andy演示了Insert，Delete，Find三种操作</p>
<p>对于Insert</p>
<ul>
<li><a class="link" href="https://cmudb.io/btree"  target="_blank" rel="noopener"
    >https://cmudb.io/btree</a> 演示demo
实际网址 <a class="link" href="https://www.cs.usfca.edu/~galles/visualization/BPlusTree.html"  target="_blank" rel="noopener"
    >https://www.cs.usfca.edu/~galles/visualization/BPlusTree.html</a></li>
<li>Degree x表示最多x个指针指向下一层, 而一个node最多有x-1个key</li>
<li>空间足够可以直接插入</li>
<li>否则需要拆分节点, 然后影响上面的inner node</li>
</ul>
<p>Delete</p>
<ul>
<li>注意规则, 一个node至少需要M/2-1个entries, 如果少于这个, 就需要进行合并, 这个过程可能会重构整个树</li>
<li>实际上，不需要到达边界后就进行拆分和合并，可以维护一个阈值范围，减少拆分合并次数</li>
</ul>
<p>在《MySQL技术内幕-InnoDB存储引擎》中，将插入和删除各分为三种情况讨论，我认为总结得很好</p>
<p><strong>插入</strong>（根据Leaf Page和Index Page分为三种情况）</p>
<ul>
<li>
<p>Leaf Page未满 &amp;&amp; Index Page未满</p>
</li>
<li>
<p>Leaf Page满 &amp;&amp; Index Page未满</p>
</li>
<li>
<p>Leaf Page满 &amp;&amp; Index Page满</p>
</li>
</ul>
<p><strong>删除</strong>（根据节点与填充因子（F）的关系分为三种情况）</p>
<ul>
<li>
<p>Leaf不小于F &amp;&amp; Inner不小于F （特殊情况：删除节点是上一层的索引节点）</p>
</li>
<li>
<p>Leaf小于F &amp;&amp; Inner不小于F</p>
</li>
<li>
<p>Leaf小于F &amp;&amp; Inner小于F</p>
</li>
</ul>
<p><strong>索引页分裂</strong></p>
<ul>
<li>
<p>当page满了，分裂一定是从中间分吗？并不是。如果key是随机的，那么从中间分更好。</p>
</li>
<li>
<p>但如果key是自增的（MySQL经常使用自增键），那么从中间分是不可取的，因为后面的key都会更大。这时可以向右分裂，直接将insert的record分裂到一个新的页面。</p>
</li>
</ul>
<h3 id="聚集索引和辅助索引">聚集索引和辅助索引</h3>
<p>聚集索引（聚簇索引）和辅助索引（非聚集索引）都是B+Tree索引下的分类，区别在于他们叶子节点上存储的数据的不同。</p>
<p>聚簇索引（clustered indexes）也称为聚集索引，聚类索引，簇集索引，聚簇索引确定表中数据的物理顺序。一般而言，在聚簇索引中，其叶子节点中保留了数据tuple，即完整的行数据。因此，使用聚簇索引搜索时，访问到了叶子节点就可以获取完整的一行数据，而不需要再根据record id去查找tuple，减少了磁盘访问次数。</p>
<p>在MySQL中，默认为primary key建立了聚集索引，把tuple保存到leaf nodes上；其他的secondary indexes中的leaf node则保存了primary key，再使用该primary key在主索引中进行查找，这个过程叫做<strong>回表</strong>，是一个比较耗时的操作（两次索引查找）。</p>
<h4 id="聚集索引">聚集索引</h4>
<ul>
<li>
<p>叶子节点中存放的是行记录数据</p>
</li>
<li>
<p>聚集索引不一定是按照物理顺序存放，因为那样会有很大的维护成本，只需要按逻辑顺序就可以了，因为叶子节点会通过指针连接起来。</p>
<ul>
<li>
<p>从另一个角度来看，由指针串连起来的有序的叶子节点，是不是即是逻辑顺序，也是物理顺序？！</p>
</li>
<li>
<p>物理顺序并不是说一个leaf page指针指向的下一个leaf page非得是和他在磁盘上的下一个page吧。</p>
</li>
</ul>
</li>
<li>
<p>MySQL执行Explain命令会得到一个查询的执行计划</p>
</li>
</ul>
<h4 id="辅助索引">辅助索引</h4>
<ul>
<li>
<p>叶子节点中存放的是主键索引（聚簇索引）的key；查找到key之后还需要到聚集索引中去找完整的数据；当不需要完整数据时，覆盖索引技术可以一定程度地避免回表</p>
</li>
<li>
<p>当进行范围查询的时候，即使匹配到了某辅助索引，也可能不使用。因为还需要到聚簇索引中获取整行数据，成本较高有时还不如全表扫描。</p>
</li>
</ul>
<h3 id="聚集索引与堆表对比">聚集索引与堆表对比</h3>
<p>InnoDB使用聚集索引，辅助索引利用primary key回表定位record数据；而Microsoft SQL Server则使用堆表的方式，即索引和数据分开存储，叶子节点保存record id（可能是pageid + offset/slot）；</p>
<p>他们各有优缺点：</p>
<p><strong>聚集索引的优点</strong>是对于primary查询，当访问到叶子节点时就可以直接获取数据，而不需要再跳到堆表；在进行范围查询的时候，在聚集索引一个page上的record在堆表上可能分散在多个page上，增加了IO次数</p>
<p><strong>聚集索引的缺点</strong>是聚集索引的叶子节点要维护record数据，使得一个leaf page上节点更少；并且从其他辅助索引查找数据还需要再经过一次聚集索引进行查询，会增加不少的IO次数，这个叫做回表。</p>
<p><strong>堆表的优点</strong>是从索引上找到的record id不需要经过聚集索引，而可以直接定位到堆表的具体位置</p>
<p><strong>堆表的缺点</strong>是范围查询节点可能较分散；以及当record需要进行更新时，会更换在堆表的位置，这时需要更新索引的record id（走一遍索引），适合更新少的负载（如OLAP）</p>
<h3 id="其他索引应用技术">其他索引应用技术</h3>
<h4 id="联合索引">联合索引</h4>
<p>对表上的多列进行索引；符合前缀索引原则。</p>
<h4 id="覆盖索引">覆盖索引</h4>
<p>从辅助索引中就可以得到查询的记录；这样就不需要进行回表</p>
<h4 id="前缀索引">前缀索引</h4>
<p>使用key的前缀作为索引，使得一个page容纳更多的节点。</p>
<p>例如用邮箱的前7位作为索引，可以节省很多空间，牺牲了一些前缀重复key的查询性能。这之间需要有一个良好的权衡。</p>
<h3 id="索引选择">索引选择</h3>
<p><strong>Cardinality值</strong></p>
<p>该值的含义是索引中唯一值的数目的估计值，在InnoDB中是在一定条件触发进行采样得到的值；它表示的是索引的选择性，是在存储引擎层实现的。</p>
<p>对于优化器来说，他会尽量选择Cardinality值接近全部record数目的索引，因为这样区分度高。</p>
<p>对比而言，如果对全国人信息的表建立一个以性别为key的索引，那么它的C值为2，还需要进行大量的遍历来进行区分。</p>
<p><strong>辅助索引的回表影响索引的选择</strong></p>
<p>对于一些范围查询，即使有对应的辅助索引，得到primary key之后还需要大范围地在聚集索引中查询，因此还不如直接全表扫描</p>
<p><strong>索引提示</strong></p>
<p>如果索引非常多，那么优化器在进行评估的时候花费的时间可能较长，还不如直接给出索引提示</p>
<p>优化器可能错误地使用某索引，导致性能非常差</p>
<p><strong>强制执行索引</strong></p>
<p>可以强制存储引擎使用某索引</p>
<h3 id="btree和b-tree的区别">B+Tree和B-Tree的区别</h3>
<p>Andy说PostgreSQL文档说它使用B-Tree, 但实际使用的是B+Tree，Andy说这个是想说B-Tree和B+Tree总是混用, 说B-Tree也可以代表B+Tee；当然，B+Tree和B-Tree是有显著的区别。</p>
<p>区别：</p>
<ol>
<li>
<p>有k个子树的中间节点包含有k个元素而B树中是k-1个元素</p>
<p>B+树</p>
<p><figure 
	>
	<a href="https://raw.githubusercontent.com/JameyWoo/FigureBed/master/hugo_imgs/640.webp" >
		<img src="https://raw.githubusercontent.com/JameyWoo/FigureBed/master/hugo_imgs/640.webp"
			
			
			
			loading="lazy"
			alt="img">
	</a>
	
	<figcaption>img</figcaption>
	
</figure></p>
<p>B-树</p>
<p><figure 
	>
	<a href="https://raw.githubusercontent.com/JameyWoo/FigureBed/master/hugo_imgs/640-1587831591792.webp" >
		<img src="https://raw.githubusercontent.com/JameyWoo/FigureBed/master/hugo_imgs/640-1587831591792.webp"
			
			
			
			loading="lazy"
			alt="img">
	</a>
	
	<figcaption>img</figcaption>
	
</figure></p>
</li>
<li>
<p><strong>B+树每个元素不保存数据，只用来索引，所有数据都保存在叶子节点</strong>。</p>
</li>
<li>
<p><strong>B+树每个父节点的元素都出现在子节点, 并且是子节点的最大元素（或者下一个page的最小元素）</strong>.</p>
</li>
<li>
<p>B+树的叶子节点用有序链表链接起来了, 因此在查询一个区间的时候不需要通过中序遍历去查找</p>
<p><figure 
	>
	<a href="https://raw.githubusercontent.com/JameyWoo/FigureBed/master/hugo_imgs/640-1587831927724.webp" >
		<img src="https://raw.githubusercontent.com/JameyWoo/FigureBed/master/hugo_imgs/640-1587831927724.webp"
			
			
			
			loading="lazy"
			alt="img">
	</a>
	
	<figcaption>img</figcaption>
	
</figure></p>
</li>
<li>
<p><strong>B树所有结点都带有卫星数据, 而B+树只有叶子节点带有卫星数据</strong>.</p>
<blockquote>
<p>需要补充的是，在数据库的聚集索引（Clustered Index）中，叶子节点直接包含卫星数据。在非聚集索引（NonClustered Index）中，叶子节点带有指向卫星数据的指针。</p>
</blockquote>
</li>
<li>
<p>B+树比B树更加矮胖, 因为它的中间节点没有卫星数据, <strong>因此能容纳更多的中间节点, 使得磁盘IO次数更少</strong>.</p>
</li>
<li>
<p>B+树性能不稳定, 因为它只要查找到结点就可以, 而B+树每次都需要查找到叶子节点.</p>
</li>
<li>
<p>B树的范围查询很繁琐, 因为需要经过中序遍历. <strong>而B+树可以通过指针快速地进行范围查询</strong>.</p>
</li>
<li>
<p><strong>B-Tree在多线程场景下性能较差, 对锁方向的要求更多, 这是B-Tree性能不如B+Tree的重要原因</strong></p>
</li>
</ol>
<h3 id="btree-leaf-node的细节">B+Tree leaf node的细节</h3>
<p>叶子节点上保留了什么数据？Andy在课上重点分析了这个问题，一般而言有两种</p>
<p><figure 
	>
	<a href="https://raw.githubusercontent.com/JameyWoo/FigureBed/master/hugo_imgs/image-20211008223114489.png" >
		<img src="https://raw.githubusercontent.com/JameyWoo/FigureBed/master/hugo_imgs/image-20211008223114489.png"
			
			
			
			loading="lazy"
			alt="image-20211008223114489">
	</a>
	
	<figcaption>image-20211008223114489</figcaption>
	
</figure></p>
<ol>
<li>
<p>第一种: value是 record ids</p>
<ul>
<li>不管是primary还是secondary index, 叶子节点上的value都是record id</li>
<li>PostgreSQL是这种代表;</li>
<li>SQLServer, Oracle默认是第一种, 可选第二种</li>
</ul>
</li>
<li>
<p>第二种: value就是tuple 数据</p>
<ul>
<li>
<p>mysql, SQLite就是这种, 但这是主要（primary）索引</p>
</li>
<li>
<p>对于secondary index, 不会保留数据副本, value和第一种一样, 都是record id</p>
</li>
</ul>
</li>
</ol>
<p>在视频中，Andy举了一个奇怪的例子</p>
<ul>
<li>
<p>PPT里B+Tree的一个图, 奇怪的例子</p>
<ul>
<li>图<figure 
	>
	<a href="https://raw.githubusercontent.com/JameyWoo/FigureBed/master/hugo_imgs/66df4438-f446-4072-a77b-6af20a440bcf-2603194.jpg" >
		<img src="https://raw.githubusercontent.com/JameyWoo/FigureBed/master/hugo_imgs/66df4438-f446-4072-a77b-6af20a440bcf-2603194.jpg"
			
			
			
			loading="lazy"
			alt="img">
	</a>
	
	<figcaption>img</figcaption>
	
</figure></li>
<li>在这个例子中, 5在inner node中出现了, 但是在leaf nodes中没有出现，这看起来是一种bug</li>
<li>Andy说这是可以的, 进行搜索的时候, 会一直搜索到leaf node, 然后发现没有5, 而inner node的5可以作为索引但是实际不存在</li>
<li>这个情况可能是进行删除时删除了leaf node上地数据但还没有来得及删除inner node地数据（或者其他情况，因为不删除中间索引也不会影响结果）</li>
<li>Andy提示，不能根据索引inner node的数据来判断一个key是否真的存在！</li>
</ul>
</li>
</ul>
<p>在一个leaf node里，key和value（tuple或者record id）是如何组织的呢？</p>
<p>有多种组织方式，如</p>
<ol>
<li>
<p>key和value连续</p>
<p><figure 
	>
	<a href="https://raw.githubusercontent.com/JameyWoo/FigureBed/master/hugo_imgs/image-20211008224007784.png" >
		<img src="https://raw.githubusercontent.com/JameyWoo/FigureBed/master/hugo_imgs/image-20211008224007784.png"
			
			
			
			loading="lazy"
			alt="image-20211008224007784">
	</a>
	
	<figcaption>image-20211008224007784</figcaption>
	
</figure></p>
</li>
<li>
<p>key和key之间连续，而每个key后面都有一个offset指向value的位置</p>
<p><figure 
	>
	<a href="https://raw.githubusercontent.com/JameyWoo/FigureBed/master/hugo_imgs/image-20211008224030268.png" >
		<img src="https://raw.githubusercontent.com/JameyWoo/FigureBed/master/hugo_imgs/image-20211008224030268.png"
			
			
			
			loading="lazy"
			alt="image-20211008224030268">
	</a>
	
	<figcaption>image-20211008224030268</figcaption>
	
</figure></p>
</li>
</ol>
<p>在这里，最主要的问题在于key和value的长度是不确定的。</p>
<h3 id="一本好书-modern-b-tree-techniques">一本好书: Modern B-Tree Techniques</h3>
<p>这是一本介绍现代B-Tree技术的书，内容非常丰富，探索了一些复杂场景，如</p>
<ul>
<li>
<p>node size</p>
<p><figure 
	>
	<a href="https://raw.githubusercontent.com/JameyWoo/FigureBed/master/hugo_imgs/image-20211008224733192.png" >
		<img src="https://raw.githubusercontent.com/JameyWoo/FigureBed/master/hugo_imgs/image-20211008224733192.png"
			
			
			
			loading="lazy"
			alt="image-20211008224733192">
	</a>
	
	<figcaption>image-20211008224733192</figcaption>
	
</figure></p>
<ul>
<li>
<p>可以使用一个buffer pool管理page</p>
</li>
<li>
<p>另一个buffer pool管理index, 设置为不同的node size</p>
</li>
</ul>
</li>
<li>
<p>merge threshold</p>
<ul>
<li>
<p>当没有达到半满状态, 就可能需要进行合并</p>
</li>
<li>
<p>但是平凡的合并拆分(阈值)的代价比较大, 所以可以进行一个权衡, 不需要马上合并</p>
</li>
<li>
<p>如果没有及时合并, 那么树可能变得不平衡; 需要垃圾回收机制调整树(重写树)</p>
</li>
</ul>
</li>
<li>
<p>variable length keys</p>
<ul>
<li>
<p>变长的key</p>
<p><figure 
	>
	<a href="https://raw.githubusercontent.com/JameyWoo/FigureBed/master/hugo_imgs/image-20211008224811657.png" >
		<img src="https://raw.githubusercontent.com/JameyWoo/FigureBed/master/hugo_imgs/image-20211008224811657.png"
			
			
			
			loading="lazy"
			alt="image-20211008224811657">
	</a>
	
	<figcaption>image-20211008224811657</figcaption>
	
</figure></p>
<ul>
<li>
<p>现在基本没有人用第一种方法了</p>
</li>
<li>
<p>也没什么人用第二种方法了; why?</p>
</li>
<li>
<p>第三种padding, 是填充如填充0, 会浪费空间, postgreSQ使用了这种方式, 例如设置varchar(2012), 不满足这个长度的就填充</p>
<ul>
<li>如果存储了超过限制的数据,  dbms可能把超出的部分截掉</li>
</ul>
</li>
<li>
<p>第四种: 间接映射, 更常用的方式</p>
<ul>
<li>
<p>为当前page的key保存offset, 重点是&quot;他们在同一个page&quot;</p>
</li>
<li>
<p>offset是定长的<figure 
	>
	<a href="https://api2.mubu.com/v3/document_image/a29348f6-f137-4887-ae2d-771dfa6ff842-2603194.jpg" >
		<img src="https://api2.mubu.com/v3/document_image/a29348f6-f137-4887-ae2d-771dfa6ff842-2603194.jpg"
			
			
			
			loading="lazy"
			alt="img">
	</a>
	
	<figcaption>img</figcaption>
	
</figure></p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>non-unique indexes 非唯一索引</p>
<ul>
<li>
<p>两种方式<figure 
	>
	<a href="https://api2.mubu.com/v3/document_image/b0192cf8-4ca5-46a7-ad11-b2c058d3d84d-2603194.jpg" >
		<img src="https://api2.mubu.com/v3/document_image/b0192cf8-4ca5-46a7-ad11-b2c058d3d84d-2603194.jpg"
			
			
			
			loading="lazy"
			alt="img">
	</a>
	
	<figcaption>img</figcaption>
	
</figure></p>
</li>
<li>
<p>第一种, 在key后面append record id, record id由page id + offset组成, 是unique的</p>
<ul>
<li>不可以用于PostgreSQL</li>
</ul>
</li>
<li>
<p>第二种是违反了B+树的一些规则</p>
<ul>
<li>将多出的部分放到overflow叶子节点上, 是垂直扩展而不是水平<figure 
	>
	<a href="https://api2.mubu.com/v3/document_image/99019500-0f68-4eba-9c01-d7a820b2e959-2603194.jpg" >
		<img src="https://api2.mubu.com/v3/document_image/99019500-0f68-4eba-9c01-d7a820b2e959-2603194.jpg"
			
			
			
			loading="lazy"
			alt="img">
	</a>
	
	<figcaption>img</figcaption>
	
</figure></li>
</ul>
</li>
<li>
<p>大多数选择使用第一种</p>
</li>
</ul>
</li>
</ul>
<h3 id="四种优化方式">四种优化方式</h3>
<ul>
<li>
<p>前缀压缩</p>
</li>
<li>
<p>后缀截断</p>
<ul>
<li>
<p>当字符串前面的字符就可以判断向左还是向右时, 是不需要使用后缀的, 因此可以截断</p>
</li>
<li>
<p>不过效果没有&quot;前缀压缩&quot;好</p>
</li>
</ul>
</li>
<li>
<p>bulk insert: 批量插入</p>
<ul>
<li><strong>已获取所有数据的时候, 可以自下而上地建立索引, 而不需要一个一个进行插入</strong><figure 
	>
	<a href="https://raw.githubusercontent.com/JameyWoo/FigureBed/master/hugo_imgs/735c6ac5-c24f-45f8-86d2-5f4818805ed4-2603194.jpg" >
		<img src="https://raw.githubusercontent.com/JameyWoo/FigureBed/master/hugo_imgs/735c6ac5-c24f-45f8-86d2-5f4818805ed4-2603194.jpg"
			
			
			
			loading="lazy"
			alt="img">
	</a>
	
	<figcaption>img</figcaption>
	
</figure></li>
</ul>
</li>
<li>
<p>pointer swizzling: 指针混写</p>
<p>swizzling是搅动, 混合的意思(鸡尾酒), <em><em>这里指page的指针可以是page id也可以是Page</em>(真实的指针)</em>*</p>
<ul>
<li>
<p>node中地指针并不是指原始指针, 而是page id<figure 
	>
	<a href="https://raw.githubusercontent.com/JameyWoo/FigureBed/master/hugo_imgs/4a5129f0-a9b4-4928-b856-f54d9133af46-2603194.jpg" >
		<img src="https://raw.githubusercontent.com/JameyWoo/FigureBed/master/hugo_imgs/4a5129f0-a9b4-4928-b856-f54d9133af46-2603194.jpg"
			
			
			
			loading="lazy"
			alt="img">
	</a>
	
	<figcaption>img</figcaption>
	
</figure></p>
</li>
<li>
<p>不过这样的代价很高, 因为page id还需要经过buffer pool去将这个page id转化再去获取page</p>
</li>
<li>
<p>可以在一个page pin住地时候, 保留他们的Page*, 因为这种情况他们在内存上的位置不会改变</p>
<p><figure 
	>
	<a href="https://raw.githubusercontent.com/JameyWoo/FigureBed/master/hugo_imgs/ff01c5b0-2ac9-4319-a7c8-c6cdeb64d939-2603194.jpg" >
		<img src="https://raw.githubusercontent.com/JameyWoo/FigureBed/master/hugo_imgs/ff01c5b0-2ac9-4319-a7c8-c6cdeb64d939-2603194.jpg"
			
			
			
			loading="lazy"
			alt="img">
	</a>
	
	<figcaption>img</figcaption>
	
</figure></p>
</li>
</ul>
</li>
</ul>
<h2 id="哈希索引">哈希索引</h2>
<p>看起来哈希索引不适合MySQL，但其实它是存在的。因为在一个存储引擎中，并不是只能有一个索引结构，每种索引都有其特点优势，因此在某些特定的情况下，哈希索引也能够有很好的性能，例如当你绝大多数查询都是点查询时。对于优化器来说，当使用哈希索引的预估成本更小时，他就会选择使用哈希索引。</p>
<p>自适应哈希索引：这是InnoDB自身创建并使用的，DBA不能干预；只能用来搜索等值的查询</p>
<h2 id="全文索引">全文索引</h2>
<p>我们在浏览器上进行搜索时，搜索引擎就是通过全文索引来给我们找到想要的网页。</p>
<p>InnoDB也支持全文索引，在支持前，很多用户因为InnoDB不支持它而使用MyISAM。</p>
<p>使用倒排索引技术来实现。</p>

</section>


    <footer class="article-footer">
    
    <section class="article-tags">
        
            <a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a>
        
            <a href="/tags/cmu-15-445/">CMU 15-445</a>
        
    </section>


    
    <section class="article-copyright">
        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <path d="M14.5 9a3.5 4 0 1 0 0 6" />
</svg>



        <span>Licensed under CC BY-NC-SA 4.0</span>
    </section>
    </footer>


    
</article>

    <aside class="related-contents--wrapper">
    
    
        <h2 class="section-title">Related contents</h2>
        <div class="related-contents">
            <div class="flex article-list--tile">
                
                    
<article class="">
    <a href="/p/cmu-15-445%E7%B3%BB%E5%88%97x-join-algorithms/">
        
        

        <div class="article-details">
            <h2 class="article-title">CMU 15-445系列x: Join Algorithms</h2>
        </div>
    </a>
</article>
                
            </div>
        </div>
    
</aside>

     
    
        
    <div class="disqus-container">
    <div id="disqus_thread"></div>
<script type="application/javascript">
    var disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "hugo-theme-stack" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</div>

<style>
    .disqus-container {
        background-color: var(--card-background);
        border-radius: var(--card-border-radius);
        box-shadow: var(--shadow-l1);
        padding: var(--card-padding);
    }
</style>

<script>
    window.addEventListener('onColorSchemeChange', (e) => {
        if (DISQUS) {
            DISQUS.reset({
                reload: true
            });
        }
    })
</script>

    

    <footer class="site-footer">
    <section class="copyright">
        &copy; 
        
            2020 - 
        
        2021 Example Site
    </section>
    
    <section class="powerby">
        Built with <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> <br />
        Theme <b><a href="https://github.com/CaiJimmy/hugo-theme-stack" target="_blank" rel="noopener" data-version="3.2.0">Stack</a></b> designed by <a href="https://jimmycai.com" target="_blank" rel="noopener">Jimmy</a>
    </section>
</footer>


    
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    
    <div class="pswp__bg"></div>

    
    <div class="pswp__scroll-wrap">

        
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                
                
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo="crossorigin="anonymous"
                defer="true"
                >
            </script><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU="crossorigin="anonymous"
                defer="true"
                >
            </script><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.css"integrity="sha256-c0uckgykQ9v5k&#43;IqViZOZKc47Jn7KQil4/MP3ySA3F8="crossorigin="anonymous"
            ><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.css"integrity="sha256-SBLU4vv6CA6lHsZ1XyTdhyjJxCjPif/TRkjnsyGAGnE="crossorigin="anonymous"
            >

            </main>
    
        <aside class="sidebar right-sidebar sticky">
            <section class="widget archives">
                <div class="widget-icon">
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <line x1="5" y1="9" x2="19" y2="9" />
  <line x1="5" y1="15" x2="19" y2="15" />
  <line x1="11" y1="4" x2="7" y2="20" />
  <line x1="17" y1="4" x2="13" y2="20" />
</svg>



                </div>
                <h2 class="widget-title section-title">Table of contents</h2>
                
                <div class="widget--toc">
                    <nav id="TableOfContents">
  <ol>
    <li><a href="#概述">概述</a></li>
    <li><a href="#索引分类">索引分类</a></li>
    <li><a href="#btree">B+Tree</a>
      <ol>
        <li><a href="#btree操作">B+Tree操作</a></li>
        <li><a href="#聚集索引和辅助索引">聚集索引和辅助索引</a>
          <ol>
            <li><a href="#聚集索引">聚集索引</a></li>
            <li><a href="#辅助索引">辅助索引</a></li>
          </ol>
        </li>
        <li><a href="#聚集索引与堆表对比">聚集索引与堆表对比</a></li>
        <li><a href="#其他索引应用技术">其他索引应用技术</a>
          <ol>
            <li><a href="#联合索引">联合索引</a></li>
            <li><a href="#覆盖索引">覆盖索引</a></li>
            <li><a href="#前缀索引">前缀索引</a></li>
          </ol>
        </li>
        <li><a href="#索引选择">索引选择</a></li>
        <li><a href="#btree和b-tree的区别">B+Tree和B-Tree的区别</a></li>
        <li><a href="#btree-leaf-node的细节">B+Tree leaf node的细节</a></li>
        <li><a href="#一本好书-modern-b-tree-techniques">一本好书: Modern B-Tree Techniques</a></li>
        <li><a href="#四种优化方式">四种优化方式</a></li>
      </ol>
    </li>
    <li><a href="#哈希索引">哈希索引</a></li>
    <li><a href="#全文索引">全文索引</a></li>
  </ol>
</nav>
                </div>
            </section>
        </aside>
    

        </div>
        <script 
                src="https://cdn.jsdelivr.net/npm/node-vibrant@3.1.5/dist/vibrant.min.js"integrity="sha256-5NovOZc4iwiAWTYIFiIM7DxKUXKWvpVEuMEPLzcm5/g="crossorigin="anonymous"
                defer="false"
                >
            </script><script type="text/javascript" src="/ts/main.js" defer></script>
<script>
    (function () {
        const customFont = document.createElement('link');
        customFont.href = "https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap";

        customFont.type = "text/css";
        customFont.rel = "stylesheet";

        document.head.appendChild(customFont);
    }());
</script>

    </body>
</html>
